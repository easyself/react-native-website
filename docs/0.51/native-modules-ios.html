<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>原生模块 · React Native 中文网</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="有时候App需要访问平台API，但React Native可能还没有相应的模块封装；或者你需要复用Objective-C、Swift或C++代码，而不是用JavaScript重新实现一遍；又或者你需要实现某些高性能、多线程的代码，譬如图片处理、数据库、或者各种高级扩展等等。"/><meta name="docsearch:version" content="0.51"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="原生模块 · React Native 中文网"/><meta property="og:type" content="website"/><meta property="og:url" content="undefined/"/><meta property="og:description" content="有时候App需要访问平台API，但React Native可能还没有相应的模块封装；或者你需要复用Objective-C、Swift或C++代码，而不是用JavaScript重新实现一遍；又或者你需要实现某些高性能、多线程的代码，譬如图片处理、数据库、或者各种高级扩展等等。"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/easyself/react-native-website@1.0.0/img/favicon.ico"/><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/highlight.js@9.18.1/styles/solarized-dark.min.css"/><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/focus-visible@5.0.2/dist/focus-visible.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/easyself/react-native-website@1.0.0/js/codeblocks.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/easyself/react-native-website@1.0.0/js/tabs.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/easyself/react-native-website@1.0.0/js/doccode0325.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/easyself/react-native-website@1.0.0/js/snack.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="https://cdn.jsdelivr.net/gh/easyself/react-native-website@1.0.0/js/scrollSpy.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/easyself/react-native-website@1.0.0/css/main.css"/><script src="https://cdn.jsdelivr.net/gh/easyself/react-native-website@1.0.0/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="https://cdn.jsdelivr.net/gh/easyself/react-native-website@1.0.0/img/header_logo.svg" alt="React Native 中文网"/><h2 class="headerTitleWithLogo">React Native 中文网</h2></a><a href="/versions"><h3>0.51</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/0.51/getting-started" target="_self">文档</a></li><li class="siteNavGroupActive"><a href="/docs/0.51/activityindicator" target="_self">API</a></li><li class=""><a href="//github.com/easyself/react-native-website/issues" target="_blank">讨论</a></li><li class=""><a href="/about" target="_self">关于</a></li><li class=""><a target="_self"></a></li><li class=""><a href="https://github.com/facebook/react-native" target="_self">GitHub</a></li><li class=""><a href="//zh-hans.reactjs.org/" target="_blank">React</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>使用指南(iOS)</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">入门基础<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/0.51/getting-started">搭建开发环境</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/tutorial">编写Hello World</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/props">Props（属性）</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/state">State（状态）</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/style">样式</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/height-and-width">高度与宽度</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/layout-with-flexbox">使用Flexbox布局</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/handling-text-input">处理文本输入</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/using-a-scrollview">如何使用滚动视图</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/using-a-listview">如何使用长列表</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/network">网络</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/more-resources">其他参考资源</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">进阶指南<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/0.51/integration-with-existing-apps">集成到现有原生应用</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/navigation">使用导航器跳转页面</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/colors">颜色</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/images">图片</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/handling-touches">处理触摸事件</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/animations">动画</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/accessibility">无障碍功能</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/timers">定时器</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/direct-manipulation">直接操作</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/debugging">调试</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/testing">自动化测试</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/javascript-environment">JavaScript环境</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/performance">性能</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/upgrading">升级</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/platform-specific-code">特定平台代码</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/gesture-responder-system">手势响应系统</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">使用指南(iOS)<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem navListItemActive"><a class="navItem" href="/docs/0.51/native-modules-ios">原生模块</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/native-component-ios">原生UI组件</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/linking-libraries-ios">链接原生库</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/running-on-device-ios">在设备上运行</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/running-on-simulator-ios">在模拟器上运行</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/communication-ios">和原生端通信</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/app-extensions">iOS应用扩展</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">使用指南(Android)<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/0.51/native-modules-android">原生模块</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/native-component-android">原生UI组件</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/headless-js-android">Headless JS（后台任务）</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/running-on-device-android">在设备上运行</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/signed-apk-android">打包APK</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/android-ui-performance">调试Android UI性能</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/android-building-from-source">从源代码编译React Native</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/communication-android">和原生端通信</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">组件<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/0.51/accessibilityinfo">AccessibilityInfo</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/activityindicator">ActivityIndicator</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/button">Button</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/checkbox">CheckBox</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/datepickerios">DatePickerIOS</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/drawerlayoutandroid">DrawerLayoutAndroid</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/flatlist">FlatList</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/image">Image</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/keyboardavoidingview">KeyboardAvoidingView</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/listview">ListView</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/listviewdatasource">ListView.DataSource</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/maskedviewios">MaskedViewIOS</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/modal">Modal</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/navigatorios">NavigatorIOS</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/picker">Picker</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/pickerios">PickerIOS</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/progressbarandroid">ProgressBarAndroid</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/progressviewios">ProgressViewIOS</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/refreshcontrol">RefreshControl</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/scrollview">ScrollView</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/sectionlist">SectionList</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/segmentedcontrolios">SegmentedControlIOS</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/slider">Slider</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/statusbar">StatusBar</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/switch">Switch</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/tabbarios">TabBarIOS</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/tabbarios-item">TabBarIOS.Item</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/text">Text</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/textinput">TextInput</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/toolbarandroid">ToolbarAndroid</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/touchablehighlight">TouchableHighlight</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/touchablenativefeedback">TouchableNativeFeedback</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/touchableopacity">TouchableOpacity</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/touchablewithoutfeedback">TouchableWithoutFeedback</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/view">View</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/viewpagerandroid">ViewPagerAndroid</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/virtualizedlist">VirtualizedList</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/webview">WebView</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">API<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/0.51/actionsheetios">ActionSheetIOS</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/alert">Alert</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/alertios">AlertIOS</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/animated">Animated</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/appregistry">AppRegistry</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/appstate">AppState</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/asyncstorage">AsyncStorage</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/backandroid">BackAndroid</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/backhandler">BackHandler</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/cameraroll">CameraRoll</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/clipboard">Clipboard</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/datepickerandroid">DatePickerAndroid</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/dimensions">Dimensions</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/easing">Easing</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/geolocation">Geolocation</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/imageeditor">ImageEditor</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/imagepickerios">ImagePickerIOS</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/imagestore">ImageStore</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/interactionmanager">InteractionManager</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/keyboard">Keyboard</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/layoutanimation">LayoutAnimation</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/linking">Linking</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/nativemethodsmixin">NativeMethodsMixin</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/netinfo">NetInfo</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/panresponder">PanResponder</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/permissionsandroid">PermissionsAndroid</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/pixelratio">PixelRatio</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/pushnotificationios">PushNotificationIOS</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/share">Share</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/stylesheet">StyleSheet</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/systrace">Systrace</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/timepickerandroid">TimePickerAndroid</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/toastandroid">ToastAndroid</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/vibration">Vibration</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/layout-props">布局样式属性</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/shadow-props">阴影样式属性</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="//easyself.github.com/react-native-website/blob/production/cndocs/native-modules-ios.md" target="_blank" rel="noreferrer noopener">帮助改进此文档</a><h1 id="__docusaurus" class="postHeaderTitle">原生模块</h1></header><article><div><span><p>有时候App需要访问平台API，但React Native可能还没有相应的模块封装；或者你需要复用Objective-C、Swift或C++代码，而不是用JavaScript重新实现一遍；又或者你需要实现某些高性能、多线程的代码，譬如图片处理、数据库、或者各种高级扩展等等。</p>
<p>我们把React Native设计为可以在其基础上编写真正的原生代码，并且可以访问平台所有的能力。这是一个相对高级的特性，我们并不认为它应当在日常开发的过程中经常出现，但具备这样的能力是很重要的。如果React Native还不支持某个你需要的原生特性，你应当可以自己实现该特性的封装。</p>
<p>本文是关于如何封装原生模块的高级向导，我们假设您已经具备Objective-C或者Swift，以及iOS核心库（Foundation、UIKit）的相关知识。</p>
<h2><a class="anchor" aria-hidden="true" id="ios-日历模块演示"></a><a href="#ios-日历模块演示" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>iOS 日历模块演示</h2>
<p>本向导将会用<a href="https://developer.apple.com/library/mac/documentation/DataManagement/Conceptual/EventKitProgGuide/Introduction/Introduction.html">iOS日历API</a>作为示例。我们的目标就是在Javascript中可以访问到iOS的日历功能。</p>
<p>在React Native中，一个“原生模块”就是一个实现了“RCTBridgeModule”协议的Objective-C类，其中RCT是ReaCT的缩写。</p>
<pre><code class="hljs css language-objective-c"><span class="hljs-comment">// CalendarManager.h</span>
#<span class="hljs-keyword">import</span> &lt;React/RCTBridgeModule.h&gt;
#<span class="hljs-keyword">import</span> &lt;React/RCTLog.h&gt;

@<span class="hljs-keyword">interface</span> <span class="hljs-symbol">CalendarManager</span> : <span class="hljs-symbol">NSObject</span> &lt;<span class="hljs-symbol">RCTBridgeModule</span>&gt;
@<span class="hljs-symbol">end</span>
</code></pre>
<p>为了实现<code>RCTBridgeModule</code>协议，你的类需要包含<code>RCT_EXPORT_MODULE()</code>宏。这个宏也可以添加一个参数用来指定在Javascript中访问这个模块的名字。如果你不指定，默认就会使用这个Objective-C类的名字。</p>
<pre><code class="hljs css language-objective-c"><span class="hljs-comment">// CalendarManager.m</span>
<span class="hljs-meta">@implementation</span> <span class="hljs-function">CalendarManager

<span class="hljs-title">RCT_EXPORT_MODULE</span><span class="hljs-params">()</span></span>;

<span class="hljs-meta">@end</span>
</code></pre>
<p>你必须明确的声明要给Javascript导出的方法，否则React Native不会导出任何方法。声明通过<code>RCT_EXPORT_METHOD()</code>宏来实现：</p>
<pre><code class="hljs css language-objective-c">RCT_EXPORT_METHOD(addEvent:(NSString *)<span class="hljs-type">name</span> <span class="hljs-keyword">location</span>:(NSString *)<span class="hljs-keyword">location</span>)
{
  RCTLogInfo(@"Pretending to create an event %@ at %@", <span class="hljs-type">name</span>, <span class="hljs-keyword">location</span>);
}
</code></pre>
<p>现在从Javascript里可以这样调用这个方法：</p>
<pre><code class="hljs css language-jsx"><span class="hljs-keyword">import</span> { NativeModules } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-native'</span>;
<span class="hljs-keyword">var</span> CalendarManager = NativeModules.CalendarManager;
CalendarManager.addEvent(<span class="hljs-string">'Birthday Party'</span>, <span class="hljs-string">'4 Privet Drive, Surrey'</span>);
</code></pre>
<blockquote>
<p><strong>注意</strong>: Javascript方法名</p>
<p>导出到Javascript的方法名是Objective-C的方法名的第一个部分。React Native还定义了一个<code>RCT_REMAP_METHOD()</code>宏，它可以指定Javascript方法名。当许多方法的第一部分相同的时候用它来避免在Javascript端的名字冲突。</p>
</blockquote>
<p>桥接到Javascript的方法返回值类型必须是<code>void</code>。React Native的桥接操作是异步的，所以要返回结果给Javascript，你必须通过回调或者触发事件来进行。（参见本文档后面的部分）</p>
<h2><a class="anchor" aria-hidden="true" id="参数类型"></a><a href="#参数类型" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>参数类型</h2>
<p><code>RCT_EXPORT_METHOD</code> 支持所有标准JSON类型，包括：</p>
<ul>
<li>string (<code>NSString</code>)</li>
<li>number (<code>NSInteger</code>, <code>float</code>, <code>double</code>, <code>CGFloat</code>, <code>NSNumber</code>)</li>
<li>boolean (<code>BOOL</code>, <code>NSNumber</code>)</li>
<li>array (<code>NSArray</code>) 包含本列表中任意类型</li>
<li>object (<code>NSDictionary</code>) 包含string类型的键和本列表中任意类型的值</li>
<li>function (<code>RCTResponseSenderBlock</code>)</li>
</ul>
<p>除此以外，任何<code>RCTConvert</code>类支持的的类型也都可以使用(参见<a href="https://github.com/facebook/react-native/blob/master/React/Base/RCTConvert.h"><code>RCTConvert</code></a>了解更多信息)。<code>RCTConvert</code>还提供了一系列辅助函数，用来接收一个JSON值并转换到原生Objective-C类型或类。</p>
<p>在我们的<code>CalendarManager</code>例子里，我们需要把事件的时间交给原生方法。我们不能在桥接通道里传递Date对象，所以需要把日期转化成字符串或数字来传递。我们可以这么实现原生函数：</p>
<pre><code class="hljs css language-objective-c">RCT_EXPORT_METHOD(<span class="hljs-name">addEvent</span>:(<span class="hljs-name">NSString</span> *)name location:(NSString *)location date:(<span class="hljs-name">nonnull</span> NSNumber *)secondsSinceUnixEpoch)
{
  NSDate *date = [RCTConvert NSDate<span class="hljs-symbol">:secondsSinceUnixEpoch</span>]<span class="hljs-comment">;</span>
}
</code></pre>
<p>或者这样：</p>
<pre><code class="hljs css language-objective-c">RCT_EXPORT_METHOD(<span class="hljs-name">addEvent</span>:(<span class="hljs-name">NSString</span> *)name location:(NSString *)location date:(<span class="hljs-name">NSString</span> *)ISO8601DateString)
{
  NSDate *date = [RCTConvert NSDate<span class="hljs-symbol">:ISO8601DateString</span>]<span class="hljs-comment">;</span>
}
</code></pre>
<p>不过我们可以依靠自动类型转换的特性，跳过手动的类型转换，而直接这么写：</p>
<pre><code class="hljs css language-objective-c">RCT_EXPORT_METHOD(addEvent:(NSString *)<span class="hljs-type">name</span> <span class="hljs-keyword">location</span>:(NSString *)<span class="hljs-keyword">location</span> <span class="hljs-type">date</span>:(NSDate *)<span class="hljs-type">date</span>)
{
  // <span class="hljs-type">Date</span> <span class="hljs-keyword">is</span> ready <span class="hljs-keyword">to</span> use!
}
</code></pre>
<p>在Javascript既可以这样：</p>
<pre><code class="hljs css language-jsx">CalendarManager.addEvent(<span class="hljs-string">'Birthday Party'</span>, <span class="hljs-string">'4 Privet Drive, Surrey'</span>, date.getTime()); <span class="hljs-comment">// 把日期以unix时间戳形式传递</span>
</code></pre>
<p>也可以这样：</p>
<pre><code class="hljs css language-jsx">CalendarManager.addEvent(<span class="hljs-string">'Birthday Party'</span>, <span class="hljs-string">'4 Privet Drive, Surrey'</span>, date.toISOString()); <span class="hljs-comment">// 把日期以ISO-8601的字符串形式传递</span>
</code></pre>
<p>两个值都会被转换为正确的<code>NSDate</code>类型。但如果提供一个不合法的值，譬如一个<code>Array</code>，则会产生一个“红屏”报错信息。</p>
<p>随着<code>CalendarManager.addEvent</code>方法变得越来越复杂，参数的个数越来越多，其中有一些可能是可选的参数。在这种情况下我们应该考虑修改我们的API，用一个dictionary来存放所有的事件参数，像这样：</p>
<pre><code class="hljs css language-objective-c"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;React/RCTConvert.h&gt;</span></span>

RCT_EXPORT_METHOD(addEvent:(<span class="hljs-built_in">NSString</span> *)name details:(<span class="hljs-built_in">NSDictionary</span> *)details)
{
  <span class="hljs-built_in">NSString</span> *location = [RCTConvert <span class="hljs-built_in">NSString</span>:details[<span class="hljs-string">@"location"</span>]];
  <span class="hljs-built_in">NSDate</span> *time = [RCTConvert <span class="hljs-built_in">NSDate</span>:details[<span class="hljs-string">@"time"</span>]];
  ...
}
</code></pre>
<p>然后在JS里这样调用：</p>
<pre><code class="hljs css language-jsx">CalendarManager.addEvent(<span class="hljs-string">'Birthday Party'</span>, {
  <span class="hljs-attr">location</span>: <span class="hljs-string">'4 Privet Drive, Surrey'</span>,
  <span class="hljs-attr">time</span>: date.toTime(),
  <span class="hljs-attr">description</span>: <span class="hljs-string">'...'</span>
})
</code></pre>
<blockquote>
<p><strong>注意</strong>: 关于数组和映射</p>
<p>Objective-C并没有提供确保这些结构体内部值的类型的方式。你的原生模块可能希望收到一个字符串数组，但如果JavaScript在调用的时候提供了一个混合number和string的数组，你会收到一个<code>NSArray</code>，里面既有<code>NSNumber</code>也有<code>NSString</code>。对于数组来说，<code>RCTConvert</code>提供了一些类型化的集合，譬如<code>NSStringArray</code>或者<code>UIColorArray</code>，你可以用在你的函数声明中。对于映射而言，开发者有责任自己调用<code>RCTConvert</code>的辅助方法来检测和转换值的类型。</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="回调函数"></a><a href="#回调函数" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>回调函数</h2>
<blockquote>
<p><strong>警告</strong></p>
<p>本章节内容目前还处在实验阶段，因为我们还并没有太多的实践经验来处理回调函数。</p>
</blockquote>
<p>原生模块还支持一种特殊的参数——回调函数。它提供了一个函数来把返回值传回给JavaScript。</p>
<pre><code class="hljs css language-objective-c"><span class="hljs-symbol">RCT_EXPORT_METHOD</span>(findEvents:(<span class="hljs-symbol">RCTResponseSenderBlock</span>)callback)
{
  <span class="hljs-symbol">NSArray</span> *events = ...
  callback(@[[<span class="hljs-symbol">NSNull</span> null], events]);
}
</code></pre>
<p><code>RCTResponseSenderBlock</code>只接受一个参数——传递给JavaScript回调函数的参数数组。在上面这个例子里我们用Node.js的常用习惯：第一个参数是一个错误对象（没有发生错误的时候为null），而剩下的部分是函数的返回值。</p>
<pre><code class="hljs css language-jsx">CalendarManager.findEvents(<span class="hljs-function">(<span class="hljs-params">error, events</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (error) {
    <span class="hljs-built_in">console</span>.error(error);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">this</span>.setState({<span class="hljs-attr">events</span>: events});
  }
})
</code></pre>
<p>原生模块通常只应调用回调函数一次。但是，它可以保存callback并在将来调用。这在封装那些通过“委托函数”来获得返回值的iOS API时最为常见。<a href="https://github.com/facebook/react-native/blob/master/React/Modules/RCTAlertManager.m"><code>RCTAlertManager</code></a>中就属于这种情况。</p>
<p>如果你想传递一个更接近<code>Error</code>类型的对象给Javascript，可以用<a href="https://github.com/facebook/react-native/blob/master/React/Base/RCTUtils.h"><code>RCTUtils.h</code></a>提供的<code>RCTMakeError</code>函数。现在它仅仅是发送了一个和Error结构一样的dictionary给Javascript，但我们考虑在将来版本里让它产生一个真正的<code>Error</code>对象。</p>
<blockquote>
<p><strong>注意</strong></p>
<p>如果你传递了回调函数，那么在原生端就必须执行它（如果传递了两个，比如onSuccess和onFail，那么执行其中一个即可），否则会导致内存泄漏。</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="promises"></a><a href="#promises" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Promises</h2>
<p><strong>译注</strong>：这一部分涉及到较新的js语法和特性，不熟悉的读者建议先阅读ES6的相关书籍和文档。</p>
<p>原生模块还可以使用promise来简化代码，搭配ES2016(ES7)标准的<code>async/await</code>语法则效果更佳。如果桥接原生方法的最后两个参数是<code>RCTPromiseResolveBlock</code>和<code>RCTPromiseRejectBlock</code>，则对应的JS方法就会返回一个Promise对象。</p>
<p>我们把上面的代码用promise来代替回调进行重构：</p>
<pre><code class="hljs css language-objective-c">RCT_REMAP_METHOD(findEvents,
                 resolver:(RCTPromiseResolveBlock)resolve
                 rejecter:(RCTPromiseRejectBlock)reject)
{
  NSArray *<span class="hljs-keyword">events</span> = ...
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">events</span>) {
    resolve(<span class="hljs-keyword">events</span>);
  } <span class="hljs-keyword">else</span> {
    reject(error);
  }
}
</code></pre>
<p>现在JavaScript端的方法会返回一个Promise。这样你就可以在一个声明了<code>async</code>的异步函数内使用<code>await</code>关键字来调用，并等待其结果返回。（虽然这样写着看起来像同步操作，但实际仍然是异步的，并不会阻塞执行来等待）。</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateEvents</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">var</span> events = <span class="hljs-keyword">await</span> CalendarManager.findEvents();

    <span class="hljs-keyword">this</span>.setState({ events });
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-built_in">console</span>.error(e);
  }
}

updateEvents();
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="多线程"></a><a href="#多线程" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>多线程</h2>
<p>原生模块不应对自己被调用时所处的线程做任何假设。React Native在一个独立的串行GCD队列中调用原生模块的方法，但这属于实现的细节，并且可能会在将来的版本中改变。通过实现方法<code>- (dispatch_queue_t)methodQueue</code>，原生模块可以指定自己想在哪个队列中被执行。具体来说，如果模块需要调用一些必须在主线程才能使用的API，那应当这样指定：</p>
<pre><code class="hljs css language-objective-c">- (<span class="hljs-keyword">dispatch_queue_t</span>)methodQueue
{
  <span class="hljs-keyword">return</span> dispatch_get_main_queue();
}
</code></pre>
<p>类似的，如果一个操作需要花费很长时间，原生模块不应该阻塞住，而是应当声明一个用于执行操作的独立队列。举个例子，<code>RCTAsyncLocalStorage</code>模块创建了自己的一个queue，这样它在做一些较慢的磁盘操作的时候就不会阻塞住React本身的消息队列：</p>
<pre><code class="hljs css language-objective-c">- (<span class="hljs-keyword">dispatch_queue_t</span>)methodQueue
{
  <span class="hljs-keyword">return</span> dispatch_queue_create(<span class="hljs-string">"com.facebook.React.AsyncLocalStorageQueue"</span>, DISPATCH_QUEUE_SERIAL);
}
</code></pre>
<p>指定的<code>methodQueue</code>会被你模块里的所有方法共享。如果你的方法中“只有一个”是耗时较长的（或者是由于某种原因必须在不同的队列中运行的），你可以在函数体内用<code>dispatch_async</code>方法来在另一个队列执行，而不影响其他方法：</p>
<pre><code class="hljs css language-objective-c"><span class="hljs-selector-tag">RCT_EXPORT_METHOD</span>(<span class="hljs-attribute">doSomethingExpensive</span>:(NSString *)param <span class="hljs-attribute">callback</span>:(RCTResponseSenderBlock)callback)
{
  <span class="hljs-selector-tag">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^{
    <span class="hljs-comment">// 在这里执行长时间的操作</span>
    ...
    <span class="hljs-comment">// 你可以在任何线程/队列中执行回调函数</span>
    <span class="hljs-selector-tag">callback</span>(@[...]);
  });
}
</code></pre>
<blockquote>
<p><strong>注意</strong>: 在模块之间共享分发队列</p>
<p><code>methodQueue</code>方法会在模块被初始化的时候被执行一次，然后会被React Native的桥接机制保存下来，所以你不需要自己保存队列的引用，除非你希望在模块的其它地方使用它。但是，如果你希望在若干个模块中共享同一个队列，则需要自己保存并返回相同的队列实例；仅仅是返回相同名字的队列是不行的。</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="依赖注入"></a><a href="#依赖注入" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>依赖注入</h2>
<p>bridge会自动注册实现了<code>RCTBridgeModule</code>协议的模块，但是你可能也希望能够初始化自定义的模块实例（这样可以注入依赖）。</p>
<p>要实现这个功能，你需要实现<code>RCTBridgeDelegate</code>协议，初始化<code>RCTBridge</code>，并且在初始化方法里指定代理。然后用初始化好的<code>RCTBridge</code>实例初始化一个<code>RCTRootView</code>。</p>
<pre><code class="hljs css language-objective-c">id&lt;RCTBridgeDelegate&gt; moduleInitialiser = <span class="hljs-comment">[<span class="hljs-comment">[classThatImplementsRCTBridgeDelegate alloc]</span> init]</span>;

RCTBridge *bridge = <span class="hljs-comment">[<span class="hljs-comment">[RCTBridge alloc]</span> initWithDelegate:moduleInitialiser launchOptions:nil]</span>;

RCTRootView *rootView = <span class="hljs-comment">[<span class="hljs-comment">[RCTRootView alloc]</span>
                        initWithBridge:bridge
                            moduleName:kModuleName
                     initialProperties:nil]</span>;
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="导出常量"></a><a href="#导出常量" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>导出常量</h2>
<p>原生模块可以导出一些常量，这些常量在JavaScript端随时都可以访问。用这种方法来传递一些静态数据，可以避免通过bridge进行一次来回交互。</p>
<pre><code class="hljs css language-objective-c">- (NSDictionary *)constantsToExport
{
  <span class="hljs-keyword">return</span> @{ @<span class="hljs-string">"firstDayOfTheWeek"</span>: @<span class="hljs-string">"Monday"</span> };
}
</code></pre>
<p>Javascript端可以随时同步地访问这个数据：</p>
<pre><code class="hljs css language-jsx"><span class="hljs-built_in">console</span>.log(CalendarManager.firstDayOfTheWeek);
</code></pre>
<p>但是注意这个常量仅仅在初始化的时候导出了一次，所以即使你在运行期间改变<code>constantToExport</code>返回的值，也不会影响到JavaScript环境下所得到的结果。</p>
<h3><a class="anchor" aria-hidden="true" id="枚举常量"></a><a href="#枚举常量" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>枚举常量</h3>
<p>用<code>NS_ENUM</code>定义的枚举类型必须要先扩展对应的RCTConvert方法才可以作为函数参数传递。</p>
<p>假设我们要导出如下的<code>NS_ENUM</code>定义：</p>
<pre><code class="hljs css language-objc"><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">NS_ENUM</span>(<span class="hljs-built_in">NSInteger</span>, <span class="hljs-built_in">UIStatusBarAnimation</span>) {
    <span class="hljs-built_in">UIStatusBarAnimationNone</span>,
    <span class="hljs-built_in">UIStatusBarAnimationFade</span>,
    <span class="hljs-built_in">UIStatusBarAnimationSlide</span>,
};
</code></pre>
<p>你需要这样来扩展RCTConvert类：</p>
<pre><code class="hljs css language-objc"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">RCTConvert</span> (<span class="hljs-title">StatusBarAnimation</span>)</span>
  RCT_ENUM_CONVERTER(<span class="hljs-built_in">UIStatusBarAnimation</span>, (@{ <span class="hljs-string">@"statusBarAnimationNone"</span> : @(<span class="hljs-built_in">UIStatusBarAnimationNone</span>),
                                               <span class="hljs-string">@"statusBarAnimationFade"</span> : @(<span class="hljs-built_in">UIStatusBarAnimationFade</span>),
                                               <span class="hljs-string">@"statusBarAnimationSlide"</span> : @(<span class="hljs-built_in">UIStatusBarAnimationSlide</span>)}),
                      <span class="hljs-built_in">UIStatusBarAnimationNone</span>, integerValue)
<span class="hljs-keyword">@end</span>
</code></pre>
<p>接着你可以这样定义方法并且导出enum值作为常量：</p>
<pre><code class="hljs css language-objc">- (<span class="hljs-built_in">NSDictionary</span> *)constantsToExport
{
  <span class="hljs-keyword">return</span> @{ <span class="hljs-string">@"statusBarAnimationNone"</span> : @(<span class="hljs-built_in">UIStatusBarAnimationNone</span>),
            <span class="hljs-string">@"statusBarAnimationFade"</span> : @(<span class="hljs-built_in">UIStatusBarAnimationFade</span>),
            <span class="hljs-string">@"statusBarAnimationSlide"</span> : @(<span class="hljs-built_in">UIStatusBarAnimationSlide</span>) }
};

RCT_EXPORT_METHOD(updateStatusBarAnimation:(<span class="hljs-built_in">UIStatusBarAnimation</span>)animation
                                completion:(RCTResponseSenderBlock)callback)
</code></pre>
<p>你的枚举现在会用上面提供的选择器进行转换（上面的例子中是<code>integerValue</code>），然后再传递给你导出的函数。</p>
<h2><a class="anchor" aria-hidden="true" id="给javascript发送事件"></a><a href="#给javascript发送事件" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>给Javascript发送事件</h2>
<p>即使没有被JavaScript调用，原生模块也可以给JavaScript发送事件通知。最好的方法是继承<code>RCTEventEmitter</code>，实现<code>suppportEvents</code>方法并调用<code>self sendEventWithName:</code>。</p>
<pre><code class="hljs css language-objective-c"><span class="hljs-comment">// CalendarManager.h</span>
#<span class="hljs-keyword">import</span> &lt;React/RCTBridgeModule.h&gt;
#<span class="hljs-keyword">import</span> &lt;React/RCTEventEmitter.h&gt;

@<span class="hljs-keyword">interface</span> <span class="hljs-symbol">CalendarManager</span> : <span class="hljs-symbol">RCTEventEmitter</span> &lt;<span class="hljs-symbol">RCTBridgeModule</span>&gt;

@<span class="hljs-symbol">end</span>
</code></pre>
<pre><code class="hljs css language-objective-c"><span class="hljs-comment">// CalendarManager.m</span>
<span class="hljs-meta">#import <span class="hljs-meta-string">"CalendarManager.h"</span></span>

<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">CalendarManager</span></span>

RCT_EXPORT_MODULE();

- (<span class="hljs-built_in">NSArray</span>&lt;<span class="hljs-built_in">NSString</span> *&gt; *)supportedEvents
{
  <span class="hljs-keyword">return</span> @[<span class="hljs-string">@"EventReminder"</span>];
}

- (<span class="hljs-keyword">void</span>)calendarEventReminderReceived:(<span class="hljs-built_in">NSNotification</span> *)notification
{
  <span class="hljs-built_in">NSString</span> *eventName = notification.userInfo[<span class="hljs-string">@"name"</span>];
  [<span class="hljs-keyword">self</span> sendEventWithName:<span class="hljs-string">@"EventReminder"</span> body:@{<span class="hljs-string">@"name"</span>: eventName}];
}

<span class="hljs-keyword">@end</span>
</code></pre>
<p>JavaScript代码可以创建一个包含你的模块的<code>NativeEventEmitter</code>实例来订阅这些事件。</p>
<pre><code class="hljs css language-jsx"><span class="hljs-keyword">import</span> { NativeEventEmitter, NativeModules } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-native'</span>;
<span class="hljs-keyword">const</span> { CalendarManager } = NativeModules;

<span class="hljs-keyword">const</span> calendarManagerEmitter = <span class="hljs-keyword">new</span> NativeEventEmitter(CalendarManager);

<span class="hljs-keyword">const</span> subscription = calendarManagerEmitter.addListener(
  <span class="hljs-string">'EventReminder'</span>,
  (reminder) =&gt; <span class="hljs-built_in">console</span>.log(reminder.name)
);
...
<span class="hljs-comment">// 别忘了取消订阅，通常在componentWillUnmount生命周期方法中实现。</span>
subscription.remove();
</code></pre>
<p>更多给JavaScript发送事件的例子请看<a href="https://github.com/facebook/react-native/blob/master/Libraries/Geolocation/RCTLocationObserver.m"><code>RCTLocationObserver</code></a>。</p>
<h2><a class="anchor" aria-hidden="true" id="优化无监听处理的事件"></a><a href="#优化无监听处理的事件" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>优化无监听处理的事件</h2>
<p>如果你发送了一个事件却没有任何监听处理，则会因此收到一个资源警告。要优化因此带来的额外开销，你可以在你的<code>RCTEventEmitter</code>子类中覆盖<code>startObserving</code>和<code>stopObserving</code>方法。</p>
<pre><code class="hljs css language-objective-c"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">CalendarManager</span></span>
{
  <span class="hljs-keyword">bool</span> hasListeners;
}

<span class="hljs-comment">// 在添加第一个监听函数时触发</span>
-(<span class="hljs-keyword">void</span>)startObserving { 
    hasListeners = <span class="hljs-literal">YES</span>;
    <span class="hljs-comment">// Set up any upstream listeners or background tasks as necessary</span>
}

<span class="hljs-comment">// Will be called when this module's last listener is removed, or on dealloc.</span>
-(<span class="hljs-keyword">void</span>)stopObserving { 
    hasListeners = <span class="hljs-literal">NO</span>;
    <span class="hljs-comment">// Remove upstream listeners, stop unnecessary background tasks</span>
}

- (<span class="hljs-keyword">void</span>)calendarEventReminderReceived:(<span class="hljs-built_in">NSNotification</span> *)notification
{
  <span class="hljs-built_in">NSString</span> *eventName = notification.userInfo[<span class="hljs-string">@"name"</span>];
  <span class="hljs-keyword">if</span> (hasListeners) { <span class="hljs-comment">// Only send events if anyone is listening</span>
    [<span class="hljs-keyword">self</span> sendEventWithName:<span class="hljs-string">@"EventReminder"</span> body:@{<span class="hljs-string">@"name"</span>: eventName}];
  }
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="从swift导出"></a><a href="#从swift导出" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>从Swift导出</h2>
<p>Swift不支持宏，所以从Swift向React Native导出类和函数需要多做一些设置，但是大致与Objective-C是相同的。</p>
<p>假设我们已经有了一个一样的<code>CalendarManager</code>，不过是用Swift实现的类:</p>
<pre><code class="hljs css language-swift"><span class="hljs-comment">// CalendarManager.swift</span>

<span class="hljs-meta">@objc</span>(<span class="hljs-type">CalendarManager</span>)
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CalendarManager</span>: <span class="hljs-title">NSObject</span> </span>{

  <span class="hljs-meta">@objc</span>(addEvent:location:date:)
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addEvent</span><span class="hljs-params">(name: String, location: String, date: NSNumber)</span></span> -&gt; <span class="hljs-type">Void</span> {
    <span class="hljs-comment">// Date is ready to use!</span>
  }

  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">constantsToExport</span><span class="hljs-params">()</span></span> -&gt; [<span class="hljs-type">AnyHashable</span>: <span class="hljs-type">Any</span>]! {
    <span class="hljs-keyword">return</span> [<span class="hljs-string">"someKey"</span>: <span class="hljs-string">"someValue"</span>]
  }

}
</code></pre>
<blockquote>
<p><strong>注意</strong>: 你必须使用@objc标记来确保类和函数对Objective-C公开。</p>
</blockquote>
<p>接着，创建一个私有的实现文件，并将必要的信息注册到React Native中。</p>
<pre><code class="hljs css language-objc"><span class="hljs-comment">// CalendarManagerBridge.m</span>
<span class="hljs-meta">#import <span class="hljs-meta-string">&lt;React/RCTBridgeModule.h&gt;</span></span>

<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">RCT_EXTERN_MODULE</span>(<span class="hljs-title">CalendarManager</span>, <span class="hljs-title">NSObject</span>)</span>

RCT_EXTERN_METHOD(addEvent:(<span class="hljs-built_in">NSString</span> *)name location:(<span class="hljs-built_in">NSString</span> *)location date:(<span class="hljs-keyword">nonnull</span> <span class="hljs-built_in">NSNumber</span> *)date)

<span class="hljs-keyword">@end</span>
</code></pre>
<p>请注意，一旦你<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html">在IOS中混用2种语言</a>, 那就还需要一个额外的桥接头文件，称作“bridging header”，用来导出Objective-C文件给Swift。如果你是通过Xcode菜单中的<code>File&gt;New File</code>来创建的Swift文件，Xcode会自动为你创建这个头文件。在这个头文件中，你需要引入<code>RCTBridgeModule.h</code>。</p>
<pre><code class="hljs css language-objc"><span class="hljs-comment">// CalendarManager-Bridging-Header.h</span>
<span class="hljs-meta">#import <span class="hljs-meta-string">&lt;React/RCTBridgeModule.h&gt;</span></span>
</code></pre>
<p>同样的，你也可以使用<code>RCT_EXTERN_REMAP_MODULE</code>和<code>RCT_EXTERN_REMAP_METHOD</code>来改变导出模块和方法的JavaScript调用名称。
了解更多信息，请参阅<a href="https://github.com/facebook/react-native/blob/master/React/Base/RCTBridgeModule.h"><code>RCTBridgeModule</code></a>.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/0.51/gesture-responder-system"><span class="arrow-prev">← </span><span>手势响应系统</span></a><a class="docs-next button" href="/docs/0.51/native-component-ios"><span>Next</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#ios-日历模块演示">iOS 日历模块演示</a></li><li><a href="#参数类型">参数类型</a></li><li><a href="#回调函数">回调函数</a></li><li><a href="#promises">Promises</a></li><li><a href="#多线程">多线程</a></li><li><a href="#依赖注入">依赖注入</a></li><li><a href="#导出常量">导出常量</a><ul class="toc-headings"><li><a href="#枚举常量">枚举常量</a></li></ul></li><li><a href="#给javascript发送事件">给Javascript发送事件</a></li><li><a href="#优化无监听处理的事件">优化无监听处理的事件</a></li><li><a href="#从swift导出">从Swift导出</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="copyright"><p style="color:inherit">React Native中文网 © 2020</p></section></footer></div></body></html>