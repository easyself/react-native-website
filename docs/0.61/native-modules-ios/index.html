<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>原生模块 · React Native 中文网</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="##### 本文档贡献者：[sunnylqm](https://github.com/search?q=sunnylqm%40qq.com+in%3Aemail&amp;type=Users)(99.81%), [xiaoqiangli.mail](https://github.com/search?q=xiaoqiangli.mail%40gmail.com+in%3Aemail&amp;type=Users)(0.19%)"/><meta name="docsearch:version" content="0.61"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="原生模块 · React Native 中文网"/><meta property="og:type" content="website"/><meta property="og:url" content="undefined/"/><meta property="og:description" content="##### 本文档贡献者：[sunnylqm](https://github.com/search?q=sunnylqm%40qq.com+in%3Aemail&amp;type=Users)(99.81%), [xiaoqiangli.mail](https://github.com/search?q=xiaoqiangli.mail%40gmail.com+in%3Aemail&amp;type=Users)(0.19%)"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/easyself/react-native-website@1.0.0/img/favicon.ico"/><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/highlight.js@9.18.1/styles/solarized-dark.min.css"/><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/focus-visible@5.0.2/dist/focus-visible.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/easyself/react-native-website@1.0.0/js/codeblocks.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/easyself/react-native-website@1.0.0/js/tabs.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/easyself/react-native-website@1.0.0/js/doccode0325.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/easyself/react-native-website@1.0.0/js/snack.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="https://cdn.jsdelivr.net/gh/easyself/react-native-website@1.0.0/js/scrollSpy.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/easyself/react-native-website@1.0.0/css/main.css"/><script src="https://cdn.jsdelivr.net/gh/easyself/react-native-website@1.0.0/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="https://cdn.jsdelivr.net/gh/easyself/react-native-website@1.0.0/img/header_logo.svg" alt="React Native 中文网"/><h2 class="headerTitleWithLogo">React Native 中文网</h2></a><a href="/versions"><h3>0.61</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/0.61/getting-started" target="_self">文档</a></li><li class=""><a href="/docs/0.61/activityindicator" target="_self">API</a></li><li class=""><a href="//github.com/easyself/react-native-website/issues" target="_blank">讨论</a></li><li class=""><a href="/about" target="_self">关于</a></li><li class=""><a target="_self"></a></li><li class=""><a href="https://github.com/facebook/react-native" target="_self">GitHub</a></li><li class=""><a href="//zh-hans.reactjs.org/" target="_blank">React</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>使用指南(iOS)</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">入门基础<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/0.61/getting-started">搭建开发环境</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/intro-react-native-components">核心组件与原生组件</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/intro-react">React基础</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/tutorial">示例教程：Hello World</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/props">Props（属性）</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/state">State（状态）</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/handling-text-input">处理文本输入</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/handling-touches">处理触摸事件</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/using-a-scrollview">使用滚动视图</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/using-a-listview">使用长列表</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/network">网络</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/sample-application-movies">示例教程：电影列表</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/more-resources">其他参考资源</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">设计<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/0.61/style">样式</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/height-and-width">高度与宽度</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/flexbox">使用Flexbox布局</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">进阶指南<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/0.61/components-and-apis">组件和API</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/fast-refresh">快速自动刷新 Fast Refresh</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/platform-specific-code">特定平台代码</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/navigation">使用导航器跳转页面</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/images">图片</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/animations">动画</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/accessibility">无障碍功能</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/improvingux">改进用户体验</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/optimizing-flatlist-configuration">列表配置优化</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/timers">定时器</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/debugging">调试</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/performance">性能</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/gesture-responder-system">手势响应系统</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/javascript-environment">JavaScript环境</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/typescript">使用TypeScript</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/direct-manipulation">直接操作</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/colors">颜色</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/integration-with-existing-apps">集成到现有原生应用</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/building-for-apple-tv">为电视和机顶盒制作应用</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/running-on-device">在设备上运行</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/upgrading">更新</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/native-modules-setup">原生模块配置</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/out-of-tree-platforms">多平台支持</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/building-from-source">从源代码编译React Native</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/publishing-forks">发布自己定制的ReactNative包</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/testing">Testing your Changes</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">使用指南(iOS)<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem navListItemActive"><a class="navItem" href="/docs/0.61/native-modules-ios">原生模块</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/native-components-ios">原生UI组件</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/linking-libraries-ios">链接原生库</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/running-on-simulator-ios">在iOS模拟器上运行</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/communication-ios">和原生端通信</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/app-extensions">iOS应用扩展</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">使用指南(Android)<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/0.61/native-modules-android">原生模块</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/native-components-android">原生UI组件</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/headless-js-android">Headless JS（后台任务）</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/signed-apk-android">打包APK</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/removing-default-permissions">移除不需要的权限</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/hermes">Using Hermes</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="//easyself.github.com/react-native-website/blob/production/cndocs/native-modules-ios.md" target="_blank" rel="noreferrer noopener">帮助改进此文档</a><h1 id="__docusaurus" class="postHeaderTitle">原生模块</h1></header><article><div><span><h5><a class="anchor" aria-hidden="true" id="本文档贡献者：sunnylqmhttpsgithubcomsearchqsunnylqm40qqcomin3aemailtypeusers9981-xiaoqianglimailhttpsgithubcomsearchqxiaoqianglimail40gmailcomin3aemailtypeusers019"></a><a href="#本文档贡献者：sunnylqmhttpsgithubcomsearchqsunnylqm40qqcomin3aemailtypeusers9981-xiaoqianglimailhttpsgithubcomsearchqxiaoqianglimail40gmailcomin3aemailtypeusers019" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>本文档贡献者：<a href="https://github.com/search?q=sunnylqm%40qq.com+in%3Aemail&amp;type=Users">sunnylqm</a>(99.81%), <a href="https://github.com/search?q=xiaoqiangli.mail%40gmail.com+in%3Aemail&amp;type=Users">xiaoqiangli.mail</a>(0.19%)</h5>
<p>有时候 App 需要访问平台 API，但 React Native 可能还没有相应的模块封装；或者你需要复用 Objective-C、Swift 或 C++代码，而不是用 JavaScript 重新实现一遍；又或者你需要实现某些高性能、多线程的代码，譬如图片处理、数据库、或者各种高级扩展等等。</p>
<p>我们把 React Native 设计为可以在其基础上编写真正的原生代码，并且可以访问平台所有的能力。这是一个相对高级的特性，我们并不认为它应当在日常开发的过程中经常出现，但具备这样的能力是很重要的。如果 React Native 还不支持某个你需要的原生特性，你应当可以自己实现该特性的封装。</p>
<p>本文是关于如何封装原生模块的高级向导，我们假设您已经具备 Objective-C 或者 Swift，以及 iOS 核心库（Foundation、UIKit）的相关知识。</p>
<h2><a class="anchor" aria-hidden="true" id="native-module-setup"></a><a href="#native-module-setup" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Native Module Setup</h2>
<p>Native modules are usually distributed as npm packages, except that for them to be native modules they will contain an Xcode library project. To get the basic scaffolding make sure to read <a href="native-modules-setup">Native Modules Setup</a> guide first.</p>
<h2><a class="anchor" aria-hidden="true" id="ios-日历模块演示"></a><a href="#ios-日历模块演示" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>iOS 日历模块演示</h2>
<p>本向导将会用<a href="https://developer.apple.com/library/mac/documentation/DataManagement/Conceptual/EventKitProgGuide/Introduction/Introduction.html">iOS 日历 API</a>作为示例。我们的目标就是在 Javascript 中可以访问到 iOS 的日历功能。</p>
<p>在 React Native 中，一个“原生模块”就是一个实现了“RCTBridgeModule”协议的 Objective-C 类，其中 RCT 是 ReaCT 的缩写。</p>
<pre><code class="hljs css language-objectivec"><span class="hljs-comment">// CalendarManager.h</span>
<span class="hljs-meta">#import <span class="hljs-meta-string">&lt;React/RCTBridgeModule.h&gt;</span></span>

<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">CalendarManager</span> : <span class="hljs-title">NSObject</span> &lt;<span class="hljs-title">RCTBridgeModule</span>&gt;</span>
<span class="hljs-keyword">@end</span>
</code></pre>
<p>为了实现<code>RCTBridgeModule</code>协议，你的类需要包含<code>RCT_EXPORT_MODULE()</code>宏。这个宏也可以添加一个参数用来指定在 JavaScript 中访问这个模块的名字。如果你不指定，默认就会使用这个 Objective-C 类的名字。如果类名以 RCT 开头，则 JavaScript 端引入的模块名会自动移除这个前缀。</p>
<pre><code class="hljs css language-objectivec"><span class="hljs-comment">// CalendarManager.m</span>
<span class="hljs-meta">#import <span class="hljs-meta-string">"CalendarManager.h"</span></span>

<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">CalendarManager</span></span>

<span class="hljs-comment">// To export a module named CalendarManager</span>
RCT_EXPORT_MODULE();

<span class="hljs-comment">// This would name the module AwesomeCalendarManager instead</span>
<span class="hljs-comment">// RCT_EXPORT_MODULE(AwesomeCalendarManager);</span>

<span class="hljs-keyword">@end</span>
</code></pre>
<p>你必须明确的声明要给 JavaScript 导出的方法，否则 React Native 不会导出任何方法。声明通过<code>RCT_EXPORT_METHOD()</code>宏来实现：</p>
<pre><code class="hljs css language-objectivec"><span class="hljs-meta">#import <span class="hljs-meta-string">"CalendarManager.h"</span></span>
<span class="hljs-meta">#import <span class="hljs-meta-string">&lt;React/RCTLog.h&gt;</span></span>

<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">CalendarManager</span></span>

RCT_EXPORT_MODULE();

RCT_EXPORT_METHOD(addEvent:(<span class="hljs-built_in">NSString</span> *)name location:(<span class="hljs-built_in">NSString</span> *)location)
{
  RCTLogInfo(<span class="hljs-string">@"Pretending to create an event %@ at %@"</span>, name, location);
}

<span class="hljs-keyword">@end</span>
</code></pre>
<p>现在从 Javascript 里可以这样调用这个方法：</p>
<pre><code class="hljs css language-jsx"><span class="hljs-keyword">import</span> {NativeModules} <span class="hljs-keyword">from</span> <span class="hljs-string">'react-native'</span>;
<span class="hljs-keyword">const</span> CalendarManager = NativeModules.CalendarManager;
CalendarManager.addEvent(<span class="hljs-string">'Birthday Party'</span>, <span class="hljs-string">'4 Privet Drive, Surrey'</span>);
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: JavaScript method names</p>
<p>The name of the method exported to JavaScript is the native method's name up to the first colon. React Native also defines a macro called <code>RCT_REMAP_METHOD()</code> to specify the JavaScript method's name. This is useful when multiple native methods are the same up to the first colon and would have conflicting JavaScript names.</p>
</blockquote>
<p>The CalendarManager module is instantiated on the Objective-C side using a [CalendarManager new] call. The return type of bridge methods is always <code>void</code>. React Native bridge is asynchronous, so the only way to pass a result to JavaScript is by using callbacks or emitting events (see below).</p>
<blockquote>
<p><strong>注意</strong>: JavaScript 方法名</p>
<p>导出到 JavaScript 的方法名是 Objective-C 的方法名的第一个部分。React Native 还定义了一个<code>RCT_REMAP_METHOD()</code>宏，它可以指定 JavaScript 方法名。因为 JavaScript 端不能有同名不同参的方法存在，所以当原生端存在重载方法时，可以使用这个宏来避免在 JavaScript 端的名字冲突。</p>
</blockquote>
<p>桥接到 JavaScript 的方法返回值类型必须是<code>void</code>。React Native 的桥接操作是异步的，所以要返回结果给 JavaScript，你必须通过回调或者触发事件来进行。（参见本文档后面的部分）</p>
<h2><a class="anchor" aria-hidden="true" id="参数类型"></a><a href="#参数类型" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>参数类型</h2>
<p><code>RCT_EXPORT_METHOD</code> 支持所有标准 JSON 类型，包括：</p>
<ul>
<li>string (<code>NSString</code>)</li>
<li>number (<code>NSInteger</code>, <code>float</code>, <code>double</code>, <code>CGFloat</code>, <code>NSNumber</code>)</li>
<li>boolean (<code>BOOL</code>, <code>NSNumber</code>)</li>
<li>array (<code>NSArray</code>) 可包含本列表中任意类型</li>
<li>object (<code>NSDictionary</code>) 可包含 string 类型的键和本列表中任意类型的值</li>
<li>function (<code>RCTResponseSenderBlock</code>)</li>
</ul>
<p>除此以外，任何<code>RCTConvert</code>类支持的的类型也都可以使用(参见<a href="https://github.com/facebook/react-native/blob/master/React/Base/RCTConvert.h"><code>RCTConvert</code></a>了解更多信息)。<code>RCTConvert</code>还提供了一系列辅助函数，用来接收一个 JSON 值并转换到原生 Objective-C 类型或类。</p>
<p>在我们的<code>CalendarManager</code>例子里，我们需要把事件的时间交给原生方法。我们不能在桥接通道里传递 Date 对象，所以需要把日期转化成字符串或数字来传递。我们可以这么实现原生函数：</p>
<pre><code class="hljs css language-objectivec">RCT_EXPORT_METHOD(addEvent:(<span class="hljs-built_in">NSString</span> *)name location:(<span class="hljs-built_in">NSString</span> *)location date:(<span class="hljs-keyword">nonnull</span> <span class="hljs-built_in">NSNumber</span> *)secondsSinceUnixEpoch)
{
  <span class="hljs-built_in">NSDate</span> *date = [RCTConvert <span class="hljs-built_in">NSDate</span>:secondsSinceUnixEpoch];
}
</code></pre>
<p>或者这样：</p>
<pre><code class="hljs css language-objectivec">RCT_EXPORT_METHOD(addEvent:(<span class="hljs-built_in">NSString</span> *)name location:(<span class="hljs-built_in">NSString</span> *)location date:(<span class="hljs-built_in">NSString</span> *)ISO8601DateString)
{
  <span class="hljs-built_in">NSDate</span> *date = [RCTConvert <span class="hljs-built_in">NSDate</span>:ISO8601DateString];
}
</code></pre>
<p>不过我们可以依靠自动类型转换的特性，跳过手动的类型转换，而直接这么写：</p>
<pre><code class="hljs css language-objectivec">RCT_EXPORT_METHOD(addEvent:(<span class="hljs-built_in">NSString</span> *)name location:(<span class="hljs-built_in">NSString</span> *)location date:(<span class="hljs-built_in">NSDate</span> *)date)
{
  <span class="hljs-comment">// Date is ready to use!</span>
}
</code></pre>
<p>对应 JavaScript 端既可以这样：</p>
<pre><code class="hljs css language-jsx">CalendarManager.addEvent(
  <span class="hljs-string">'Birthday Party'</span>,
  <span class="hljs-string">'4 Privet Drive, Surrey'</span>,
  date.getTime(),
); <span class="hljs-comment">// 把日期以unix时间戳形式传递</span>
</code></pre>
<p>也可以这样：</p>
<pre><code class="hljs css language-jsx">CalendarManager.addEvent(
  <span class="hljs-string">'Birthday Party'</span>,
  <span class="hljs-string">'4 Privet Drive, Surrey'</span>,
  date.toISOString(),
); <span class="hljs-comment">// 把日期以ISO-8601的字符串形式传递</span>
</code></pre>
<p>两个值都会被转换为正确的<code>NSDate</code>类型。但如果提供一个不合法的值，譬如一个<code>Array</code>，则会产生一个“红屏”报错信息。</p>
<p>随着<code>CalendarManager.addEvent</code>方法变得越来越复杂，参数的个数越来越多，其中有一些可能是可选的参数。在这种情况下我们应该考虑修改我们的 API，用一个 dictionary 来存放所有的事件参数，像这样：</p>
<pre><code class="hljs css language-objectivec"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;React/RCTConvert.h&gt;</span></span>

RCT_EXPORT_METHOD(addEvent:(<span class="hljs-built_in">NSString</span> *)name details:(<span class="hljs-built_in">NSDictionary</span> *)details)
{
  <span class="hljs-built_in">NSString</span> *location = [RCTConvert <span class="hljs-built_in">NSString</span>:details[<span class="hljs-string">@"location"</span>]];
  <span class="hljs-built_in">NSDate</span> *time = [RCTConvert <span class="hljs-built_in">NSDate</span>:details[<span class="hljs-string">@"time"</span>]];
  ...
}
</code></pre>
<p>然后在 JS 里这样调用：</p>
<pre><code class="hljs css language-jsx">CalendarManager.addEvent(<span class="hljs-string">'Birthday Party'</span>, {
  <span class="hljs-attr">location</span>: <span class="hljs-string">'4 Privet Drive, Surrey'</span>,
  <span class="hljs-attr">time</span>: date.getTime(),
  <span class="hljs-attr">description</span>: <span class="hljs-string">'...'</span>,
});
</code></pre>
<blockquote>
<p><strong>注意</strong>: 关于数组和映射</p>
<p>Objective-C 并没有提供确保这些结构体内部值的类型的方式。你的原生模块可能希望收到一个字符串数组，但如果 JavaScript 在调用的时候提供了一个混合 number 和 string 的数组，你会收到一个<code>NSArray</code>，里面既有<code>NSNumber</code>也有<code>NSString</code>。对于数组来说，<code>RCTConvert</code>提供了一些类型化的集合，譬如<code>NSStringArray</code>或者<code>UIColorArray</code>，你可以用在你的函数声明中。对于映射而言，开发者有责任自己调用<code>RCTConvert</code>的辅助方法来检测和转换值的类型。</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="回调函数"></a><a href="#回调函数" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>回调函数</h2>
<blockquote>
<p><strong>警告</strong></p>
<p>本章节内容目前还处在实验阶段，因为我们还并没有太多的实践经验来处理回调函数。</p>
</blockquote>
<p>原生模块还支持一种特殊的参数——回调函数。它提供了一个函数来把返回值传回给 JavaScript。</p>
<pre><code class="hljs css language-objectivec">RCT_EXPORT_METHOD(findEvents:(RCTResponseSenderBlock)callback)
{
  <span class="hljs-built_in">NSArray</span> *events = ...
  callback(@[[<span class="hljs-built_in">NSNull</span> null], events]);
}
</code></pre>
<p><code>RCTResponseSenderBlock</code>只接受一个参数——传递给 JavaScript 回调函数的参数数组。在上面这个例子里我们用 Node.js 的常用习惯：第一个参数是一个错误对象（没有发生错误的时候为 null），而剩下的部分是函数的返回值。</p>
<pre><code class="hljs css language-jsx">CalendarManager.findEvents(<span class="hljs-function">(<span class="hljs-params">error, events</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (error) {
    <span class="hljs-built_in">console</span>.error(error);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">this</span>.setState({<span class="hljs-attr">events</span>: events});
  }
});
</code></pre>
<p>原生模块通常只应调用回调函数一次。但是，它可以保存 callback 并在将来调用。这在封装那些通过“委托函数”来获得返回值的 iOS API 时最为常见。<a href="https://github.com/facebook/react-native/blob/master/React/Modules/RCTAlertManager.m"><code>RCTAlertManager</code></a>中就属于这种情况。</p>
<p>如果你想传递一个更接近<code>Error</code>类型的对象给 JavaScript，可以用<a href="https://github.com/facebook/react-native/blob/master/React/Base/RCTUtils.h"><code>RCTUtils.h</code></a>提供的<code>RCTMakeError</code>函数。现在它仅仅是发送了一个和 Error 结构一样的 dictionary 给 JavaScript，但我们考虑在将来版本里让它产生一个真正的<code>Error</code>对象。</p>
<h2><a class="anchor" aria-hidden="true" id="promises"></a><a href="#promises" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Promises</h2>
<p><strong>译注</strong>：这一部分涉及到较新的 js 语法和特性，不熟悉的读者建议先阅读 ES6 的相关书籍和文档。</p>
<p>原生模块还可以使用 promise 来简化代码，搭配 ES2016(ES7)标准的<code>async/await</code>语法则效果更佳。如果桥接原生方法的最后两个参数是<code>RCTPromiseResolveBlock</code>和<code>RCTPromiseRejectBlock</code>，则对应的 JS 方法就会返回一个 Promise 对象。</p>
<p>我们把上面的代码用 promise 来代替回调进行重构：</p>
<pre><code class="hljs css language-objectivec">RCT_REMAP_METHOD(findEvents,
                 findEventsWithResolver:(RCTPromiseResolveBlock)resolve
                 rejecter:(RCTPromiseRejectBlock)reject)
{
  <span class="hljs-built_in">NSArray</span> *events = ...
  <span class="hljs-keyword">if</span> (events) {
    resolve(events);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">NSError</span> *error = ...
    reject(<span class="hljs-string">@"no_events"</span>, <span class="hljs-string">@"There were no events"</span>, error);
  }
}
</code></pre>
<p>现在 JavaScript 端的方法会返回一个 Promise。这样你就可以在一个声明了<code>async</code>的异步函数内使用<code>await</code>关键字来调用，并等待其结果返回。（虽然这样写着看起来像同步操作，但实际仍然是异步的，并不会阻塞执行来等待）。</p>
<pre><code class="hljs css language-jsx"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateEvents</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> events = <span class="hljs-keyword">await</span> CalendarManager.findEvents();

    <span class="hljs-keyword">this</span>.setState({events});
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-built_in">console</span>.error(e);
  }
}

updateEvents();
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="多线程"></a><a href="#多线程" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>多线程</h2>
<p>原生模块不应对自己被调用时所处的线程做任何假设。React Native 在一个独立的串行 GCD 队列中调用原生模块的方法，但这属于实现的细节，并且可能会在将来的版本中改变。通过实现方法<code>- (dispatch_queue_t)methodQueue</code>，原生模块可以指定自己想在哪个队列中被执行。具体来说，如果模块需要调用一些必须在主线程才能使用的 API，那应当这样指定：</p>
<pre><code class="hljs css language-objectivec">- (<span class="hljs-built_in">dispatch_queue_t</span>)methodQueue
{
  <span class="hljs-keyword">return</span> dispatch_get_main_queue();
}
</code></pre>
<p>类似的，如果一个操作需要花费很长时间，原生模块不应该阻塞住，而是应当声明一个用于执行操作的独立队列。举个例子，<code>RCTAsyncLocalStorage</code>模块创建了自己的一个 queue，这样它在做一些较慢的磁盘操作的时候就不会阻塞住 React 本身的消息队列：</p>
<pre><code class="hljs css language-objectivec">- (<span class="hljs-built_in">dispatch_queue_t</span>)methodQueue
{
  <span class="hljs-keyword">return</span> dispatch_queue_create(<span class="hljs-string">"com.facebook.React.AsyncLocalStorageQueue"</span>, DISPATCH_QUEUE_SERIAL);
}
</code></pre>
<p>指定的<code>methodQueue</code>会被你模块里的所有方法共享。如果你的方法中“只有一个”是耗时较长的（或者是由于某种原因必须在不同的队列中运行的），你可以在函数体内用<code>dispatch_async</code>方法来在另一个队列执行，而不影响其他方法：</p>
<pre><code class="hljs css language-objectivec">RCT_EXPORT_METHOD(doSomethingExpensive:(<span class="hljs-built_in">NSString</span> *)param callback:(RCTResponseSenderBlock)callback)
{
  <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^{
    <span class="hljs-comment">// 在这里执行长时间的操作</span>
    ...
    <span class="hljs-comment">// 你可以在任何线程/队列中执行回调函数</span>
    callback(@[...]);
  });
}
</code></pre>
<blockquote>
<p><strong>注意</strong>: 在模块之间共享分发队列</p>
<p><code>methodQueue</code>方法会在模块被初始化的时候被执行一次，然后会被 React Native 的桥接机制保存下来，所以你不需要自己保存队列的引用，除非你希望在模块的其它地方使用它。但是，如果你希望在若干个模块中共享同一个队列，则需要自己保存并返回相同的队列实例；仅仅是返回相同名字的队列是不行的。</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="依赖注入"></a><a href="#依赖注入" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>依赖注入</h2>
<p>bridge 会自动注册实现了<code>RCTBridgeModule</code>协议的模块，但是你可能也希望能够初始化自定义的模块实例（这样可以注入依赖）。</p>
<p>要实现这个功能，你需要实现<code>RCTBridgeDelegate</code>协议，初始化<code>RCTBridge</code>，并且在初始化方法里指定代理。然后用初始化好的<code>RCTBridge</code>实例初始化一个<code>RCTRootView</code>。</p>
<pre><code class="hljs css language-objectivec"><span class="hljs-keyword">id</span>&lt;RCTBridgeDelegate&gt; moduleInitialiser = [[classThatImplementsRCTBridgeDelegate alloc] init];

RCTBridge *bridge = [[RCTBridge alloc] initWithDelegate:moduleInitialiser launchOptions:<span class="hljs-literal">nil</span>];

RCTRootView *rootView = [[RCTRootView alloc]
                        initWithBridge:bridge
                            moduleName:kModuleName
                     initialProperties:<span class="hljs-literal">nil</span>];
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="导出常量"></a><a href="#导出常量" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>导出常量</h2>
<p>原生模块可以导出一些常量，这些常量在 JavaScript 端随时都可以访问。用这种方法来传递一些静态数据，可以避免通过 bridge 进行一次来回交互。</p>
<pre><code class="hljs css language-objectivec">- (<span class="hljs-built_in">NSDictionary</span> *)constantsToExport
{
  <span class="hljs-keyword">return</span> @{ <span class="hljs-string">@"firstDayOfTheWeek"</span>: <span class="hljs-string">@"Monday"</span> };
}
</code></pre>
<p>JavaScript 端可以随时同步地访问这个数据：</p>
<pre><code class="hljs css language-jsx"><span class="hljs-built_in">console</span>.log(CalendarManager.firstDayOfTheWeek);
</code></pre>
<p>但是注意这个常量仅仅在初始化的时候导出了一次，所以即使你在运行期间改变<code>constantToExport</code>返回的值，也不会影响到 JavaScript 环境下所得到的结果。</p>
<h3><a class="anchor" aria-hidden="true" id="implementing--requiresmainqueuesetup"></a><a href="#implementing--requiresmainqueuesetup" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Implementing <code>+ requiresMainQueueSetup</code></h3>
<p>If you override <code>- constantsToExport</code> then you should also implement <code>+ requiresMainQueueSetup</code> to let React Native know if your module needs to be initialized on the main thread. Otherwise you will see a warning that in the future your module may be initialized on a background thread unless you explicitly opt out with <code>+ requiresMainQueueSetup</code>:</p>
<pre><code class="hljs css language-objectivec">+ (<span class="hljs-built_in">BOOL</span>)requiresMainQueueSetup
{
  <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;  <span class="hljs-comment">// only do this if your module initialization relies on calling UIKit!</span>
}
</code></pre>
<p>If your module does not require access to UIKit, then you should respond to <code>+ requiresMainQueueSetup</code> with <code>NO</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="枚举常量"></a><a href="#枚举常量" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>枚举常量</h3>
<p>用<code>NS_ENUM</code>定义的枚举类型必须要先扩展对应的 RCTConvert 方法才可以作为函数参数传递。</p>
<p>假设我们要导出如下的<code>NS_ENUM</code>定义：</p>
<pre><code class="hljs css language-objectivec"><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">NS_ENUM</span>(<span class="hljs-built_in">NSInteger</span>, <span class="hljs-built_in">UIStatusBarAnimation</span>) {
    <span class="hljs-built_in">UIStatusBarAnimationNone</span>,
    <span class="hljs-built_in">UIStatusBarAnimationFade</span>,
    <span class="hljs-built_in">UIStatusBarAnimationSlide</span>,
};
</code></pre>
<p>你需要这样来扩展 RCTConvert 类：</p>
<pre><code class="hljs css language-objectivec"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">RCTConvert</span> (<span class="hljs-title">StatusBarAnimation</span>)</span>
  RCT_ENUM_CONVERTER(<span class="hljs-built_in">UIStatusBarAnimation</span>, (@{ <span class="hljs-string">@"statusBarAnimationNone"</span> : @(<span class="hljs-built_in">UIStatusBarAnimationNone</span>),
                                               <span class="hljs-string">@"statusBarAnimationFade"</span> : @(<span class="hljs-built_in">UIStatusBarAnimationFade</span>),
                                               <span class="hljs-string">@"statusBarAnimationSlide"</span> : @(<span class="hljs-built_in">UIStatusBarAnimationSlide</span>)}),
                      <span class="hljs-built_in">UIStatusBarAnimationNone</span>, integerValue)
<span class="hljs-keyword">@end</span>
</code></pre>
<p>接着你可以这样定义方法并且导出 enum 值作为常量：</p>
<pre><code class="hljs css language-objectivec">- (<span class="hljs-built_in">NSDictionary</span> *)constantsToExport
{
  <span class="hljs-keyword">return</span> @{ <span class="hljs-string">@"statusBarAnimationNone"</span> : @(<span class="hljs-built_in">UIStatusBarAnimationNone</span>),
            <span class="hljs-string">@"statusBarAnimationFade"</span> : @(<span class="hljs-built_in">UIStatusBarAnimationFade</span>),
            <span class="hljs-string">@"statusBarAnimationSlide"</span> : @(<span class="hljs-built_in">UIStatusBarAnimationSlide</span>) };
};

RCT_EXPORT_METHOD(updateStatusBarAnimation:(<span class="hljs-built_in">UIStatusBarAnimation</span>)animation
                                completion:(RCTResponseSenderBlock)callback)
</code></pre>
<p>你的枚举现在会用上面提供的选择器进行转换（上面的例子中是<code>integerValue</code>），然后再传递给你导出的函数。</p>
<h2><a class="anchor" aria-hidden="true" id="给-javascript-端发送事件"></a><a href="#给-javascript-端发送事件" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>给 JavaScript 端发送事件</h2>
<p>即使没有被 JavaScript 调用，原生模块也可以给 JavaScript 发送事件通知。最好的方法是继承<code>RCTEventEmitter</code>，实现<code>suppportEvents</code>方法并调用<code>self sendEventWithName:</code>。</p>
<pre><code class="hljs css language-objectivec"><span class="hljs-comment">// CalendarManager.h</span>
<span class="hljs-meta">#import <span class="hljs-meta-string">&lt;React/RCTBridgeModule.h&gt;</span></span>
<span class="hljs-meta">#import <span class="hljs-meta-string">&lt;React/RCTEventEmitter.h&gt;</span></span>

<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">CalendarManager</span> : <span class="hljs-title">RCTEventEmitter</span> &lt;<span class="hljs-title">RCTBridgeModule</span>&gt;</span>

<span class="hljs-keyword">@end</span>
</code></pre>
<pre><code class="hljs css language-objectivec"><span class="hljs-comment">// CalendarManager.m</span>
<span class="hljs-meta">#import <span class="hljs-meta-string">"CalendarManager.h"</span></span>

<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">CalendarManager</span></span>

RCT_EXPORT_MODULE();

- (<span class="hljs-built_in">NSArray</span>&lt;<span class="hljs-built_in">NSString</span> *&gt; *)supportedEvents
{
  <span class="hljs-keyword">return</span> @[<span class="hljs-string">@"EventReminder"</span>];
}

- (<span class="hljs-keyword">void</span>)calendarEventReminderReceived:(<span class="hljs-built_in">NSNotification</span> *)notification
{
  <span class="hljs-built_in">NSString</span> *eventName = notification.userInfo[<span class="hljs-string">@"name"</span>];
  [<span class="hljs-keyword">self</span> sendEventWithName:<span class="hljs-string">@"EventReminder"</span> body:@{<span class="hljs-string">@"name"</span>: eventName}];
}

<span class="hljs-keyword">@end</span>
</code></pre>
<p>JavaScript 端的代码可以创建一个包含你的模块的<code>NativeEventEmitter</code>实例来订阅这些事件。</p>
<pre><code class="hljs css language-jsx"><span class="hljs-keyword">import</span> { NativeEventEmitter, NativeModules } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-native'</span>;
<span class="hljs-keyword">const</span> { CalendarManager } = NativeModules;

<span class="hljs-keyword">const</span> calendarManagerEmitter = <span class="hljs-keyword">new</span> NativeEventEmitter(CalendarManager);

<span class="hljs-keyword">const</span> subscription = calendarManagerEmitter.addListener(
  <span class="hljs-string">'EventReminder'</span>,
  (reminder) =&gt; <span class="hljs-built_in">console</span>.log(reminder.name)
);
...
<span class="hljs-comment">// 别忘了取消订阅，通常在componentWillUnmount生命周期方法中实现。</span>
subscription.remove();
</code></pre>
<p>更多给 JavaScript 发送事件的例子请参考<a href="https://github.com/facebook/react-native/blob/master/Libraries/Geolocation/RCTLocationObserver.m"><code>RCTLocationObserver</code></a>。</p>
<h3><a class="anchor" aria-hidden="true" id="优化无监听处理的事件"></a><a href="#优化无监听处理的事件" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>优化无监听处理的事件</h3>
<p>如果你发送了一个事件却没有任何监听处理，则会因此收到一个资源警告。要优化因此带来的额外开销，你可以在你的<code>RCTEventEmitter</code>子类中覆盖<code>startObserving</code>和<code>stopObserving</code>方法。</p>
<pre><code class="hljs css language-objectivec"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">CalendarManager</span></span>
{
  <span class="hljs-keyword">bool</span> hasListeners;
}

<span class="hljs-comment">// 在添加第一个监听函数时触发</span>
-(<span class="hljs-keyword">void</span>)startObserving {
    hasListeners = <span class="hljs-literal">YES</span>;
    <span class="hljs-comment">// Set up any upstream listeners or background tasks as necessary</span>
}

<span class="hljs-comment">// Will be called when this module's last listener is removed, or on dealloc.</span>
-(<span class="hljs-keyword">void</span>)stopObserving {
    hasListeners = <span class="hljs-literal">NO</span>;
    <span class="hljs-comment">// Remove upstream listeners, stop unnecessary background tasks</span>
}

- (<span class="hljs-keyword">void</span>)calendarEventReminderReceived:(<span class="hljs-built_in">NSNotification</span> *)notification
{
  <span class="hljs-built_in">NSString</span> *eventName = notification.userInfo[<span class="hljs-string">@"name"</span>];
  <span class="hljs-keyword">if</span> (hasListeners) { <span class="hljs-comment">// Only send events if anyone is listening</span>
    [<span class="hljs-keyword">self</span> sendEventWithName:<span class="hljs-string">@"EventReminder"</span> body:@{<span class="hljs-string">@"name"</span>: eventName}];
  }
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="从-swift-导出"></a><a href="#从-swift-导出" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>从 Swift 导出</h2>
<p>Swift 不支持宏，所以从 Swift 向 React Native 导出类和函数需要多做一些设置，但是大致与 Objective-C 是相同的。</p>
<p>假设我们已经有了一个一样的<code>CalendarManager</code>，不过是用 Swift 实现的类:</p>
<pre><code class="hljs css language-swift"><span class="hljs-comment">// CalendarManager.swift</span>

<span class="hljs-meta">@objc</span>(<span class="hljs-type">CalendarManager</span>)
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CalendarManager</span>: <span class="hljs-title">NSObject</span> </span>{

  <span class="hljs-meta">@objc</span>(addEvent:location:date:)
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addEvent</span><span class="hljs-params">(name: String, location: String, date: NSNumber)</span></span> -&gt; <span class="hljs-type">Void</span> {
    <span class="hljs-comment">// Date is ready to use!</span>
  }

  <span class="hljs-meta">@objc</span>
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">constantsToExport</span><span class="hljs-params">()</span></span> -&gt; [<span class="hljs-type">String</span>: <span class="hljs-type">Any</span>]! {
    <span class="hljs-keyword">return</span> [<span class="hljs-string">"someKey"</span>: <span class="hljs-string">"someValue"</span>]
  }

}
</code></pre>
<blockquote>
<p><strong>注意</strong>: 你必须使用@objc 标记来确保类和函数对 Objective-C 公开。</p>
</blockquote>
<p>接着，创建一个私有的实现文件，并将必要的信息注册到 React Native 中。</p>
<pre><code class="hljs css language-objectivec"><span class="hljs-comment">// CalendarManagerBridge.m</span>
<span class="hljs-meta">#import <span class="hljs-meta-string">&lt;React/RCTBridgeModule.h&gt;</span></span>

<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">RCT_EXTERN_MODULE</span>(<span class="hljs-title">CalendarManager</span>, <span class="hljs-title">NSObject</span>)</span>

RCT_EXTERN_METHOD(addEvent:(<span class="hljs-built_in">NSString</span> *)name location:(<span class="hljs-built_in">NSString</span> *)location date:(<span class="hljs-keyword">nonnull</span> <span class="hljs-built_in">NSNumber</span> *)date)

<span class="hljs-keyword">@end</span>
</code></pre>
<p>请注意，一旦你<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html">在 IOS 中混用 2 种语言</a>, 那就还需要一个额外的桥接头文件，称作“bridging header”，用来导出 Objective-C 文件给 Swift。如果你是通过 Xcode 菜单中的<code>File&gt;New File</code>来创建的 Swift 文件，Xcode 会自动为你创建这个头文件。在这个头文件中，你需要引入<code>RCTBridgeModule.h</code>。</p>
<pre><code class="hljs css language-objectivec"><span class="hljs-comment">// CalendarManager-Bridging-Header.h</span>
<span class="hljs-meta">#import <span class="hljs-meta-string">&lt;React/RCTBridgeModule.h&gt;</span></span>
</code></pre>
<p>同样的，你也可以使用<code>RCT_EXTERN_REMAP_MODULE</code>和<code>RCT_EXTERN_REMAP_METHOD</code>来改变导出模块和方法的 JavaScript 调用名称。了解更多信息，请参阅<a href="https://github.com/facebook/react-native/blob/master/React/Base/RCTBridgeModule.h"><code>RCTBridgeModule</code></a>.</p>
<blockquote>
<p><strong>Important when making third party modules</strong>: Static libraries with Swift are only supported in Xcode 9 and later. In order for the Xcode project to build when you use Swift in the iOS static library you include in the module, your main app project must contain Swift code and a bridging header itself. If your app project does not contain any Swift code, a workaround can be a single empty .swift file and an empty bridging header.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="reserved-method-names"></a><a href="#reserved-method-names" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reserved Method Names</h2>
<h3><a class="anchor" aria-hidden="true" id="invalidate"></a><a href="#invalidate" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>invalidate()</h3>
<p>Native modules can conform to the <a href="https://github.com/facebook/react-native/blob/aa0ef15335fe27c0c193e3e968789886d82e82ed/React/Base/RCTInvalidating.h">RCTInvalidating</a> protocol on iOS by implementing the <code>invalidate</code> method. This method <a href="https://github.com/facebook/react-native/blob/18e3303cd46a72668caae46e28c7c6ae69fbf8f8/ReactCommon/turbomodule/core/platform/ios/RCTTurboModuleManager.mm#L456">can be invoked</a> when the native bridge is invalidated (ie: on devmode reload). You should avoid implementing this method in general, as this mechanism exists for backwards compatibility and may be removed in the future.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/0.61/testing"><span class="arrow-prev">← </span><span>Testing your Changes</span></a><a class="docs-next button" href="/docs/0.61/native-components-ios"><span>原生UI组件</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#native-module-setup">Native Module Setup</a></li><li><a href="#ios-日历模块演示">iOS 日历模块演示</a></li><li><a href="#参数类型">参数类型</a></li><li><a href="#回调函数">回调函数</a></li><li><a href="#promises">Promises</a></li><li><a href="#多线程">多线程</a></li><li><a href="#依赖注入">依赖注入</a></li><li><a href="#导出常量">导出常量</a><ul class="toc-headings"><li><a href="#implementing--requiresmainqueuesetup">Implementing <code>+ requiresMainQueueSetup</code></a></li><li><a href="#枚举常量">枚举常量</a></li></ul></li><li><a href="#给-javascript-端发送事件">给 JavaScript 端发送事件</a><ul class="toc-headings"><li><a href="#优化无监听处理的事件">优化无监听处理的事件</a></li></ul></li><li><a href="#从-swift-导出">从 Swift 导出</a></li><li><a href="#reserved-method-names">Reserved Method Names</a><ul class="toc-headings"><li><a href="#invalidate">invalidate()</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="copyright"><p style="color:inherit">React Native中文网 © 2020</p></section></footer></div></body></html>