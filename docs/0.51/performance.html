<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>性能 · React Native 中文网</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="使用 React Native 替代基于 WebView 的框架来开发 App 的一个强有力的理由，就是为了使 App 可以达到每秒 60 帧（足够流畅），并且能有类似原生 App 的外观和手感。因此我们也尽可能地优化 React Native 去实现这一目标，使开发者能集中精力处理 App 的业务逻辑，而不用费心考虑性能。但是，总还是有一些地方有所欠缺，以及在某些场合 React Native 还不能够替你决定如何进行优化（用原生代码写也无法避免），因此人工的干预依然是必要的。"/><meta name="docsearch:version" content="0.51"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="性能 · React Native 中文网"/><meta property="og:type" content="website"/><meta property="og:url" content="undefined/"/><meta property="og:description" content="使用 React Native 替代基于 WebView 的框架来开发 App 的一个强有力的理由，就是为了使 App 可以达到每秒 60 帧（足够流畅），并且能有类似原生 App 的外观和手感。因此我们也尽可能地优化 React Native 去实现这一目标，使开发者能集中精力处理 App 的业务逻辑，而不用费心考虑性能。但是，总还是有一些地方有所欠缺，以及在某些场合 React Native 还不能够替你决定如何进行优化（用原生代码写也无法避免），因此人工的干预依然是必要的。"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/easyself/react-native-website@1.0.0/img/favicon.ico"/><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/highlight.js@9.18.1/styles/solarized-dark.min.css"/><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/focus-visible@5.0.2/dist/focus-visible.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/easyself/react-native-website@1.0.0/js/codeblocks.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/easyself/react-native-website@1.0.0/js/tabs.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/easyself/react-native-website@1.0.0/js/doccode0325.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/easyself/react-native-website@1.0.0/js/snack.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="https://cdn.jsdelivr.net/gh/easyself/react-native-website@1.0.0/js/scrollSpy.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/easyself/react-native-website@1.0.0/css/main.css"/><script src="https://cdn.jsdelivr.net/gh/easyself/react-native-website@1.0.0/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="https://cdn.jsdelivr.net/gh/easyself/react-native-website@1.0.0/img/header_logo.svg" alt="React Native 中文网"/><h2 class="headerTitleWithLogo">React Native 中文网</h2></a><a href="/versions"><h3>0.51</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/0.51/getting-started" target="_self">文档</a></li><li class="siteNavGroupActive"><a href="/docs/0.51/activityindicator" target="_self">API</a></li><li class=""><a href="//github.com/easyself/react-native-website/issues" target="_blank">讨论</a></li><li class=""><a href="/about" target="_self">关于</a></li><li class=""><a target="_self"></a></li><li class=""><a href="https://github.com/facebook/react-native" target="_self">GitHub</a></li><li class=""><a href="//zh-hans.reactjs.org/" target="_blank">React</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>进阶指南</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">入门基础<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/0.51/getting-started">搭建开发环境</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/tutorial">编写Hello World</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/props">Props（属性）</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/state">State（状态）</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/style">样式</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/height-and-width">高度与宽度</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/layout-with-flexbox">使用Flexbox布局</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/handling-text-input">处理文本输入</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/using-a-scrollview">如何使用滚动视图</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/using-a-listview">如何使用长列表</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/network">网络</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/more-resources">其他参考资源</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">进阶指南<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/0.51/integration-with-existing-apps">集成到现有原生应用</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/navigation">使用导航器跳转页面</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/colors">颜色</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/images">图片</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/handling-touches">处理触摸事件</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/animations">动画</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/accessibility">无障碍功能</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/timers">定时器</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/direct-manipulation">直接操作</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/debugging">调试</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/testing">自动化测试</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/javascript-environment">JavaScript环境</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/0.51/performance">性能</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/upgrading">升级</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/platform-specific-code">特定平台代码</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/gesture-responder-system">手势响应系统</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">使用指南(iOS)<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/0.51/native-modules-ios">原生模块</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/native-component-ios">原生UI组件</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/linking-libraries-ios">链接原生库</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/running-on-device-ios">在设备上运行</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/running-on-simulator-ios">在模拟器上运行</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/communication-ios">和原生端通信</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/app-extensions">iOS应用扩展</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">使用指南(Android)<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/0.51/native-modules-android">原生模块</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/native-component-android">原生UI组件</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/headless-js-android">Headless JS（后台任务）</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/running-on-device-android">在设备上运行</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/signed-apk-android">打包APK</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/android-ui-performance">调试Android UI性能</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/android-building-from-source">从源代码编译React Native</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/communication-android">和原生端通信</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">组件<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/0.51/accessibilityinfo">AccessibilityInfo</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/activityindicator">ActivityIndicator</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/button">Button</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/checkbox">CheckBox</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/datepickerios">DatePickerIOS</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/drawerlayoutandroid">DrawerLayoutAndroid</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/flatlist">FlatList</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/image">Image</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/keyboardavoidingview">KeyboardAvoidingView</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/listview">ListView</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/listviewdatasource">ListView.DataSource</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/maskedviewios">MaskedViewIOS</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/modal">Modal</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/navigatorios">NavigatorIOS</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/picker">Picker</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/pickerios">PickerIOS</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/progressbarandroid">ProgressBarAndroid</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/progressviewios">ProgressViewIOS</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/refreshcontrol">RefreshControl</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/scrollview">ScrollView</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/sectionlist">SectionList</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/segmentedcontrolios">SegmentedControlIOS</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/slider">Slider</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/statusbar">StatusBar</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/switch">Switch</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/tabbarios">TabBarIOS</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/tabbarios-item">TabBarIOS.Item</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/text">Text</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/textinput">TextInput</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/toolbarandroid">ToolbarAndroid</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/touchablehighlight">TouchableHighlight</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/touchablenativefeedback">TouchableNativeFeedback</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/touchableopacity">TouchableOpacity</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/touchablewithoutfeedback">TouchableWithoutFeedback</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/view">View</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/viewpagerandroid">ViewPagerAndroid</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/virtualizedlist">VirtualizedList</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/webview">WebView</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">API<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/0.51/actionsheetios">ActionSheetIOS</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/alert">Alert</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/alertios">AlertIOS</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/animated">Animated</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/appregistry">AppRegistry</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/appstate">AppState</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/asyncstorage">AsyncStorage</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/backandroid">BackAndroid</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/backhandler">BackHandler</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/cameraroll">CameraRoll</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/clipboard">Clipboard</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/datepickerandroid">DatePickerAndroid</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/dimensions">Dimensions</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/easing">Easing</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/geolocation">Geolocation</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/imageeditor">ImageEditor</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/imagepickerios">ImagePickerIOS</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/imagestore">ImageStore</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/interactionmanager">InteractionManager</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/keyboard">Keyboard</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/layoutanimation">LayoutAnimation</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/linking">Linking</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/nativemethodsmixin">NativeMethodsMixin</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/netinfo">NetInfo</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/panresponder">PanResponder</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/permissionsandroid">PermissionsAndroid</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/pixelratio">PixelRatio</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/pushnotificationios">PushNotificationIOS</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/share">Share</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/stylesheet">StyleSheet</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/systrace">Systrace</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/timepickerandroid">TimePickerAndroid</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/toastandroid">ToastAndroid</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/vibration">Vibration</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/layout-props">布局样式属性</a></li><li class="navListItem"><a class="navItem" href="/docs/0.51/shadow-props">阴影样式属性</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="//easyself.github.com/react-native-website/blob/production/cndocs/performance.md" target="_blank" rel="noreferrer noopener">帮助改进此文档</a><h1 id="__docusaurus" class="postHeaderTitle">性能</h1></header><article><div><span><p>使用 React Native 替代基于 WebView 的框架来开发 App 的一个强有力的理由，就是为了使 App 可以达到每秒 60 帧（足够流畅），并且能有类似原生 App 的外观和手感。因此我们也尽可能地优化 React Native 去实现这一目标，使开发者能集中精力处理 App 的业务逻辑，而不用费心考虑性能。但是，总还是有一些地方有所欠缺，以及在某些场合 React Native 还不能够替你决定如何进行优化（用原生代码写也无法避免），因此人工的干预依然是必要的。
本文的目的是教给你一些基本的知识，来帮你排查性能方面的问题，以及探讨这些问题产生的原因和推荐的解决方法。</p>
<h2><a class="anchor" aria-hidden="true" id="关于帧你所需要知道的"></a><a href="#关于帧你所需要知道的" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>关于“帧”你所需要知道的</h2>
<p>老一辈人常常把电影称为“移动的画”，是因为视频中逼真的动态效果其实是一种幻觉，这种幻觉是由一组静态的图片以一个稳定的速度快速变化所产生的。我们把这组图片中的每一张图片叫做一帧，而每秒钟显示的帧数直接的影响了视频（或者说用户界面）的流畅度和真实感。iOS 设备提供了每秒 60 的帧率，这就留给了开发者和 UI 系统大约 16.67ms 来完成生成一张静态图片（帧）所需要的所有工作。如果在这分派的 16.67ms 之内没有能够完成这些工作，就会引发‘丢帧’的后果，使界面表现的不够流畅。</p>
<p>下面要讲的事情可能更为复杂：请先调出你应用的开发菜单，打开<code>Show FPS Monitor</code>. 你会注意到有两个不同的帧率.</p>
<h3><a class="anchor" aria-hidden="true" id="javascript-帧率"></a><a href="#javascript-帧率" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JavaScript 帧率</h3>
<p>对大多数 React Native 应用来说，业务逻辑是运行在 JavaScript 线程上的。这是 React 应用所在的线程，也是发生 API 调用，以及处理触摸事件等操作的线程。更新数据到原生支持的视图是批量进行的，并且在事件循环每进行一次的时候被发送到原生端，这一步通常会在一帧时间结束之前处理完（如果一切顺利的话）。如果 JavaScript 线程有一帧没有及时响应，就被认为发生了一次丢帧。 例如，你在一个复杂应用的根组件上调用了<code>this.setState</code>，从而导致一次开销很大的子组件树的重绘，可想而知，这可能会花费 200ms 也就是整整 12 帧的丢失。此时，任何由 JavaScript 控制的动画都会卡住。只要卡顿超过 100ms，用户就会明显的感觉到。</p>
<p>这种情况经常发生在 Navigator 的切换过程中：当你 push 一个新的路由时，JavaScript 需要绘制新场景所需的所有组件，以发送正确的命令给原生端去创建视图。由于切换是由 JavaScript 线程所控制，因此经常会占用若干帧的时间，引起一些卡顿。有的时候，组件会在<code>componentDidMount</code>函数中做一些额外的事情，这甚至可能会导致页面切换过程中多达一秒的卡顿。</p>
<p>另一个例子是触摸事件的响应：如果你正在 JavaScript 线程处理一个跨越多个帧的工作，你可能会注意到 TouchableOpacity 的响应被延迟了。这是因为 JavaScript 线程太忙了，不能够处理主线程发送过来的原始触摸事件。结果 TouchableOpacity 就不能及时响应这些事件并命令主线程的页面去调整透明度了。</p>
<h3><a class="anchor" aria-hidden="true" id="主线程-也即-ui-线程-帧率"></a><a href="#主线程-也即-ui-线程-帧率" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>主线程 (也即 UI 线程) 帧率</h3>
<p>很多人会注意到，<code>NavigatorIOS</code>的性能要比 Navigator 好的多。原因就是它的切换动画是完全在主线程上执行的，因此不会被 JavaScript 线程上的掉帧所影响。（<a href="using-navigators.html">阅读关于为何你仍然需要使用 Navigator</a>）</p>
<p>同样，当 JavaScript 线程卡住的时候，你仍然可以欢快的上下滚动 ScrollView，因为 ScrollView 运行在主线程之上（尽管滚动事件会被分发到 JS 线程，但是接收这些事件对于滚动这个动作来说并不必要）。</p>
<h2><a class="anchor" aria-hidden="true" id="性能问题的常见原因"></a><a href="#性能问题的常见原因" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>性能问题的常见原因</h2>
<h3><a class="anchor" aria-hidden="true" id="consolelog-语句"></a><a href="#consolelog-语句" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>console.log 语句</h3>
<p>在运行打好了离线包的应用时，控制台打印语句可能会极大地拖累 JavaScript 线程。注意有些第三方调试库也可能包含控制台打印语句，比如<a href="https://github.com/evgenyrodionov/redux-logger">redux-logger</a>，所以在发布应用前请务必仔细检查，确保全部移除。</p>
<blockquote>
<p>这里有个小技巧可以在发布时屏蔽掉所有的<code>console.*</code>调用。React Native 中有一个全局变量<code>__DEV__</code>用于指示当前运行环境是否是开发环境。我们可以据此在正式环境中替换掉系统原先的 console 实现。</p>
</blockquote>
<pre><code class="hljs css language-js"><span class="hljs-keyword">if</span> (!__DEV__) {
  global.console = {
    <span class="hljs-attr">info</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {},
    <span class="hljs-attr">log</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {},
    <span class="hljs-attr">warn</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {},
    <span class="hljs-attr">debug</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {},
    <span class="hljs-attr">error</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {}
  };
}
</code></pre>
<p>这样在打包发布时，所有的控制台语句就会被自动替换为空函数，而在调试时它们仍然会被正常调用。</p>
<blockquote>
<p>还有个<a href="https://babeljs.io/docs/plugins/transform-remove-console/">babel 插件</a>可以帮你移除所有的<code>console.*</code>调用。首先需要使用<code>yarn add --dev babel-plugin-transform-remove-console</code>来安装，然后在项目根目录下编辑（或者是新建）一个名为·.babelrc`的文件，在其中加入：</p>
</blockquote>
<pre><code class="hljs css language-json">{
  <span class="hljs-attr">"env"</span>: {
    <span class="hljs-attr">"production"</span>: {
      <span class="hljs-attr">"plugins"</span>: [<span class="hljs-string">"transform-remove-console"</span>]
    }
  }
}
</code></pre>
<p>这样在打包发布时，所有的控制台语句就会被自动移除，而在调试时它们仍然会被正常调用。</p>
<h3><a class="anchor" aria-hidden="true" id="开发模式-devtrue"></a><a href="#开发模式-devtrue" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>开发模式 (dev=true)</h3>
<p>JavaScript 线程的性能在开发模式下是很糟糕的。这是不可避免的，因为有许多工作需要在运行的时候去做，譬如使你获得良好的警告和错误信息，又比如验证属性类型（propTypes）以及产生各种其他的警告。</p>
<h3><a class="anchor" aria-hidden="true" id="缓慢的导航器navigator切换"></a><a href="#缓慢的导航器navigator切换" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缓慢的导航器(Navigator)切换</h3>
<p>如之前说，<code>Navigator</code>的动画是由 JavaScript 线程所控制的。想象一下“从右边推入”这个场景的切换：每一帧中，新的场景从右向左移动，从屏幕右边缘开始（不妨认为是 320 单位宽的的 x 轴偏移），最终移动到 x 轴偏移为 0 的屏幕位置。切换过程中的每一帧，JavaScript 线程都需要发送一个新的 x 轴偏移量给主线程。如果 JavaScript 线程卡住了，它就无法处理这项事情，因而这一帧就无法更新，动画就被卡住了。</p>
<p>长远的解决方法，其中一部分是要允许基于 JavaScript 的动画从主线程分离。同样是上面的例子，我们可以在切换动画开始的时候计算出一个列表，其中包含所有的新的场景需要的 x 轴偏移量，然后一次发送到主线程以某种优化的方式执行。由于 JavaScript 线程已经从更新 x 轴偏移量给主线程这个职责中解脱了出来，因此 JavaScript 线程中的掉帧就不是什么大问题了 —— 用户将基本上不会意识到这个问题，因为用户的注意力会被流畅的切换动作所吸引。</p>
<p>新的<a href="https://reactnavigation.org/">React Navigation</a>库的一大目标就是为了解决这个问题。React Navigation 中的视图是原生组件，同时用到了运行在原生线程上的<code>Animated</code>动画库，因而性能表现十分流畅。</p>
<h3><a class="anchor" aria-hidden="true" id="listview-初始化渲染太慢以及列表过长时滚动性能太差"></a><a href="#listview-初始化渲染太慢以及列表过长时滚动性能太差" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ListView 初始化渲染太慢以及列表过长时滚动性能太差</h3>
<p>这是一个频繁出现的问题。因为 iOS 配备了 UITableView，通过重用底层的 UIViews 实现了非常高性能的体验（相比之下 ListView 的性能没有那么好）。用 React Native 实现相同效果的工作仍正在进行中，但是在此之前，我们有一些可用的方法来稍加改进性能以满足我们的需求。</p>
<h4><a class="anchor" aria-hidden="true" id="initiallistsize"></a><a href="#initiallistsize" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>initialListSize</h4>
<p>这个属性定义了在首次渲染中绘制的行数。如果我们关注于快速的显示出页面，可以设置<code>initialListSize</code>为 1，然后我们会发现其他行在接下来的帧中被快速绘制到屏幕上。而每帧所显示的行数由<code>pageSize</code>所决定。</p>
<h4><a class="anchor" aria-hidden="true" id="pagesize"></a><a href="#pagesize" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>pageSize</h4>
<p>在初始渲染也就是<code>initialListSize</code>被使用之后，ListView 将利用<code>pageSize</code>来决定每一帧所渲染的行数。默认值为 1 —— 但是如果你的页面很小，而且渲染的开销不大的话，你会希望这个值更大一些。稍加调整，你会发现它所起到的作用。</p>
<h4><a class="anchor" aria-hidden="true" id="scrollrenderaheaddistance"></a><a href="#scrollrenderaheaddistance" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>scrollRenderAheadDistance</h4>
<p>“在将要进入屏幕区域之前的某个位置，开始绘制一行，距离按像素计算。”</p>
<p>如果我们有一个 2000 个元素的列表，并且立刻全部渲染出来的话，无论是内存还是计算资源都会显得很匮乏。还很可能导致非常可怕的阻塞。因此<code>scrollRenderAheadDistance</code>允许我们来指定一个超过视野范围之外所需要渲染的行数。</p>
<h4><a class="anchor" aria-hidden="true" id="removeclippedsubviews"></a><a href="#removeclippedsubviews" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>removeClippedSubviews</h4>
<p>“当这一选项设置为 true 的时候，超出屏幕的子视图（同时<code>overflow</code>值为<code>hidden</code>）会从它们原生的父视图中移除。这个属性可以在列表很长的时候提高滚动的性能。默认为 false。（0.14 版本后默认为 true）”</p>
<p>这是一个应用在长列表上极其重要的优化。Android 上，<code>overflow</code>值总是<code>hidden</code>的，所以你不必担心没有设置它。而在 iOS 上，你需要确保在行容器上设置了<code>overflow: hidden</code>。</p>
<h3><a class="anchor" aria-hidden="true" id="我的组件渲染太慢，我不需要立即显示全部"></a><a href="#我的组件渲染太慢，我不需要立即显示全部" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>我的组件渲染太慢，我不需要立即显示全部</h3>
<p>这在初次浏览 ListView 时很常见，适当的使用它是获得稳定性能的关键。就像之前所提到的，它可以提供一些手段在不同帧中来分开渲染页面，稍加改进就可以满足你的需求。此外要记住的是，ListView 也可以横向滚动。</p>
<h3><a class="anchor" aria-hidden="true" id="在重绘一个几乎没有什么变化的页面时，js-帧率严重降低"></a><a href="#在重绘一个几乎没有什么变化的页面时，js-帧率严重降低" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>在重绘一个几乎没有什么变化的页面时，JS 帧率严重降低</h3>
<p>如果你正在使用一个 ListView，你必须提供一个<code>rowHasChanged</code>函数，它通过快速的算出某一行是否需要重绘，来减少很多不必要的工作。如果你使用了不可变的数据结构，这项工作就只需检查其引用是否相等。</p>
<p>同样的，你可以实现<code>shouldComponentUpdate</code>函数来指明在什么样的确切条件下，你希望这个组件得到重绘。如果你编写的是纯粹的组件（返回值完全由 props 和 state 所决定），你可以利用<code>PureComponent</code>来为你做这个工作。再强调一次，不可变的数据结构在提速方面非常有用 —— 当你不得不对一个长列表对象做一个深度的比较，它会使重绘你的整个组件更加快速，而且代码量更少。</p>
<h3><a class="anchor" aria-hidden="true" id="由于在-javascript-线程中同时做很多事情，导致-js-线程掉帧"></a><a href="#由于在-javascript-线程中同时做很多事情，导致-js-线程掉帧" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>由于在 JavaScript 线程中同时做很多事情，导致 JS 线程掉帧</h3>
<p>“导航切换极慢”是该问题的常见表现。在其他情形下，这种问题也可能会出现。使用<code>InteractionManager</code>是一个好的方法，但是如果在动画中，为了用户体验的开销而延迟其他工作并不太能接受，那么你可以考虑一下使用<code>LayoutAnimation</code>。</p>
<p><code>Animated</code>的接口一般会在 JavaScript 线程中计算出所需要的每一个关键帧，而<code>LayoutAnimation</code>则利用了<code>Core Animation</code>，使动画不会被 JS 线程和主线程的掉帧所影响。</p>
<p>举一个需要使用这项功能的例子：比如需要给一个模态框做动画（从下往上划动，并在半透明遮罩中淡入），而这个模态框正在初始化，并且可能响应着几个网络请求，渲染着页面的内容，并且还在更新着打开这个模态框的父页面。了解更多有关如何使用 LayoutAnimation 的信息，请查看<a href="/docs/animations.html">动画指南</a>。</p>
<p>注意：</p>
<ul>
<li><code>LayoutAnimation</code>只工作在“一次性”的动画上（&quot;静态&quot;动画） -- 如果动画可能会被中途取消，你还是需要使用<code>Animated</code>。</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="在屏幕上移动视图（滚动，切换，旋转）时，ui-线程掉帧"></a><a href="#在屏幕上移动视图（滚动，切换，旋转）时，ui-线程掉帧" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>在屏幕上移动视图（滚动，切换，旋转）时，UI 线程掉帧</h3>
<p>当具有透明背景的文本位于一张图片上时，或者在每帧重绘视图时需要用到透明合成的任何其他情况下，这种现象尤为明显。设置<code>shouldRasterizeIOS</code>或者<code>renderToHardwareTextureAndroid</code>属性可以显著改善这一现象。
注意不要过度使用该特性，否则你的内存使用量将会飞涨。在使用时，要评估你的性能和内存使用情况。如果你没有需要移动这个视图的需求，请关闭这一属性。</p>
<h3><a class="anchor" aria-hidden="true" id="使用动画改变图片的尺寸时，ui-线程掉帧"></a><a href="#使用动画改变图片的尺寸时，ui-线程掉帧" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用动画改变图片的尺寸时，UI 线程掉帧</h3>
<p>在 iOS 上，每次调整 Image 组件的宽度或者高度，都需要重新裁剪和缩放原始图片。这个操作开销会非常大，尤其是大的图片。比起直接修改尺寸，更好的方案是使用<code>transform: [{scale}]</code>的样式属性来改变尺寸。比如当你点击一个图片，要将它放大到全屏的时候，就可以使用这个属性。</p>
<h3><a class="anchor" aria-hidden="true" id="touchable-系列组件不能很好的响应"></a><a href="#touchable-系列组件不能很好的响应" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Touchable 系列组件不能很好的响应</h3>
<p>有些时候，如果我们有一项操作与点击事件所带来的透明度改变或者高亮效果发生在同一帧中，那么有可能在<code>onPress</code>函数结束之前我们都看不到这些效果。比如在<code>onPress</code>执行了一个<code>setState</code>的操作，这个操作需要大量计算工作并且导致了掉帧。对此的一个解决方案是将<code>onPress</code>处理函数中的操作封装到<code>requestAnimationFrame</code>中：</p>
<pre><code class="hljs css language-jsx">handleOnPress() {
  <span class="hljs-comment">// 谨记在使用requestAnimationFrame、setTimeout以及setInterval时</span>
  <span class="hljs-comment">// 要使用TimerMixin（其作用是在组件unmount时，清除所有定时器）</span>
  <span class="hljs-keyword">this</span>.requestAnimationFrame(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">this</span>.doExpensiveAction();
  });
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="分析"></a><a href="#分析" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分析</h2>
<p>你可以利用内置的分析器来同时获取 JavaScript 线程和主线程中代码执行情况的详细信息。</p>
<p>对于 iOS 来说，Instruments 是一个宝贵的工具库，Android 的话，你可以使用 systrace，参见<a href="/docs/android-ui-performance.html#content">调试 Android UI 性能</a>。</p>
<h2><a class="anchor" aria-hidden="true" id="拆包和内联引用"></a><a href="#拆包和内联引用" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>拆包和内联引用</h2>
<p>如果你有一个较为庞大的应用程序，你可能要考虑使用拆分和内联引用。这对于具有大量页面的应用程序是非常有用的，这些页面在应用程序的典型使用过程中可能不会被打开。通常对于启动后一段时间内不需要大量代码的应用程序来说是非常有用的。例如应用程序包含复杂的配置文件屏幕或较少使用的功能，但大多数会话只涉及访问应用程序的主屏幕更新。我们可以通过使用打包器的<code>unbundle</code>特性来优化<code>bundle</code>的加载，并且内联引用这些功能和页面（当它们被实际使用时）。</p>
<h3><a class="anchor" aria-hidden="true" id="loading-javascript"></a><a href="#loading-javascript" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Loading JavaScript</h3>
<p>在 react-native 执行 JS 代码之前，必须将代码加载到内存中并进行解析。如果你加载了一个 50MB 的 bundle，那么所有的 50mb 都必须被加载和解析才能被执行。拆分后的优化是，启动时只加载 50MB 中实际需要的部分，并随着需要的部分逐渐加载更多的包。</p>
<h3><a class="anchor" aria-hidden="true" id="内联引用"></a><a href="#内联引用" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>内联引用</h3>
<p>内联引用(require 代替 import)可以延迟模块或文件的加载，直到实际需要该文件。一个基本的例子看起来像这样：</p>
<h4><a class="anchor" aria-hidden="true" id="优化前"></a><a href="#优化前" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>优化前</h4>
<pre><code class="hljs"><span class="hljs-keyword">import</span> <span class="hljs-type">React</span>, { <span class="hljs-type">Component</span> } from <span class="hljs-symbol">'reac</span>t';
<span class="hljs-keyword">import</span> { <span class="hljs-type">Text</span> } from <span class="hljs-symbol">'react</span>-native';
<span class="hljs-comment">// ... import some very expensive modules</span>

<span class="hljs-comment">// You may want to log at the file level to verify when this is happening</span>
console.log(<span class="hljs-symbol">'VeryExpensive</span> component loaded');

export <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VeryExpensive</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
  <span class="hljs-comment">// lots and lots of code</span>
  render() {
    <span class="hljs-keyword">return</span> &lt;<span class="hljs-type">Text</span>&gt;<span class="hljs-type">Very</span> <span class="hljs-type">Expensive</span> <span class="hljs-type">Component</span>&lt;/<span class="hljs-type">Text</span>&gt;;
  }
}
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="优化后"></a><a href="#优化后" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>优化后</h4>
<pre><code class="hljs"><span class="hljs-keyword">import</span> React, { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { TouchableOpacity, View, Text } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-native'</span>;

<span class="hljs-keyword">let</span> VeryExpensive = <span class="hljs-literal">null</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Optimized</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
  state = { <span class="hljs-attr">needsExpensive</span>: <span class="hljs-literal">false</span> };

  didPress = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (VeryExpensive == <span class="hljs-literal">null</span>) {
      VeryExpensive = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./VeryExpensive'</span>).default;
    }

    <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
      <span class="hljs-attr">needsExpensive</span>: <span class="hljs-literal">true</span>,
    }));
  };

  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">marginTop:</span> <span class="hljs-attr">20</span> }}&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">TouchableOpacity</span> <span class="hljs-attr">onPress</span>=<span class="hljs-string">{this.didPress}</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">Text</span>&gt;</span>Load<span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">TouchableOpacity</span>&gt;</span>
        {this.state.needsExpensive ? <span class="hljs-tag">&lt;<span class="hljs-name">VeryExpensive</span> /&gt;</span> : null}
      <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span>
    );
  }
}
</code></pre>
<p>即使没有使用拆包，内联引用也会使启动时间减少，因为优化后的代码只有在第一次 require 时才会执行。</p>
<h3><a class="anchor" aria-hidden="true" id="启用拆包unbundling"></a><a href="#启用拆包unbundling" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>启用拆包(Unbundling)</h3>
<p>在 iOS 上 unbundling 将创建一个简单的索引文件，React Native 将一次加载一个模块。在 Android 上，默认情况下它会为每个模块创建一组文件。你可以像 iOS 一样，强制 Android 只创建一个文件，但使用多个文件可以提高性能，并降低内存占用。</p>
<p>通过编辑 build phase &quot;Bundle React Native code and images&quot;，在 Xcode 中启用 unbundling。在<code>../node_modules/react-native/packager/react-native-xcode.sh</code> 添加 <code>export BUNDLE_COMMAND=&quot;unbundle&quot;</code>:</p>
<pre><code class="hljs"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">BUNDLE_COMMAND</span>=<span class="hljs-string">"unbundle"</span>
<span class="hljs-builtin-name">export</span> <span class="hljs-attribute">NODE_BINARY</span>=node
<span class="hljs-built_in">..</span>/node_modules/react-native/packager/react-native-xcode.sh
</code></pre>
<p>在 Android 上，通过编辑你的 android/app/build.gradle 文件启用 unbundling。在<code>apply from: &quot;../../node_modules/react-native/react.gradle&quot;</code>之前修改或添加<code>project.ext.react</code>：</p>
<pre><code class="hljs"><span class="hljs-attr">project.ext.react</span> = [
  bundleCommand: <span class="hljs-string">"unbundle"</span>,
]
</code></pre>
<p>如果在 Android 上，你想使用单个索引文件（如前所述），请在 Android 上使用以下行：</p>
<pre><code class="hljs">project.ext.react = [
<span class="hljs-symbol">  bundleCommand:</span> <span class="hljs-string">"unbundle"</span>,
<span class="hljs-symbol">  extraPackagerArgs:</span> [<span class="hljs-string">"--indexed-unbundle"</span>]
]
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="配置预加载及内联引用"></a><a href="#配置预加载及内联引用" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>配置预加载及内联引用</h3>
<p>现在我们已经拆分了我们的代码，然而调用 require 会造成额外的开销。当遇到尚未加载的模块时，现在需要通过桥发送消息。这主要会影响到启动速度，因为在应用程序加载初始模块时可能触发相当大量的请求调用。幸运的是，我们可以配置一部分模块进行预加载。为了做到这一点，你将需要实现某种形式的内联引用。</p>
<h3><a class="anchor" aria-hidden="true" id="添加-packager-配置文件"></a><a href="#添加-packager-配置文件" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>添加 packager 配置文件</h3>
<p>在项目中创建一个名为 packager 的文件夹，并创建一个名为 config.js 的文件。添加以下内容：</p>
<pre><code class="hljs">const<span class="hljs-built_in"> config </span>= {
  getTransformOptions: () =&gt; {
    return {
      transform: { inlineRequires: <span class="hljs-literal">true</span> },
    };
  },
};

module.exports =<span class="hljs-built_in"> config;
</span></code></pre>
<p>在 Xcode 的 Build phase 中添加<code>export BUNDLE_CONFIG=&quot;packager/config.js&quot;</code></p>
<pre><code class="hljs"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">BUNDLE_COMMAND</span>=<span class="hljs-string">"unbundle"</span>
<span class="hljs-builtin-name">export</span> <span class="hljs-attribute">BUNDLE_CONFIG</span>=<span class="hljs-string">"packager/config.js"</span>
<span class="hljs-builtin-name">export</span> <span class="hljs-attribute">NODE_BINARY</span>=node
<span class="hljs-built_in">..</span>/node_modules/react-native/packager/react-native-xcode.sh
</code></pre>
<p>编辑 android/app/build.gradle 文件，添加<code>bundleConfig: &quot;packager/config.js&quot;,</code></p>
<pre><code class="hljs">project.ext.react = [
<span class="hljs-symbol">  bundleCommand:</span> <span class="hljs-string">"unbundle"</span>,
<span class="hljs-symbol">  bundleConfig:</span> <span class="hljs-string">"packager/config.js"</span>
]
</code></pre>
<p>最后，在 package.json 的“scripts”下修改“start”命令来启用配置文件：</p>
<p><code>&quot;start&quot;: &quot;node node_modules/react-native/local-cli/cli.js start --config ../../../../packager/config.js&quot;,</code></p>
<p>此时用<code>npm start</code>启动你的 packager 服务即会加载配置文件。请注意，如果你仍然通过 xcode 或是 react-native run-android 等方式自动启动 packager 服务，则由于没有使用上面的参数，不会加载配置文件。</p>
<h3><a class="anchor" aria-hidden="true" id="调试预加载的模块"></a><a href="#调试预加载的模块" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>调试预加载的模块</h3>
<p>在您的根文件 (index.(ios|android).js) 中，您可以在初始导入(initial imports)之后添加以下内容：</p>
<pre><code class="hljs"><span class="hljs-keyword">const</span> modules = <span class="hljs-built_in">require</span>.getModules();
<span class="hljs-keyword">const</span> moduleIds = <span class="hljs-built_in">Object</span>.keys(modules);
<span class="hljs-keyword">const</span> loadedModuleNames = moduleIds
  .filter(<span class="hljs-function"><span class="hljs-params">moduleId</span> =&gt;</span> modules[moduleId].isInitialized)
  .map(<span class="hljs-function"><span class="hljs-params">moduleId</span> =&gt;</span> modules[moduleId].verboseName);
<span class="hljs-keyword">const</span> waitingModuleNames = moduleIds
  .filter(<span class="hljs-function"><span class="hljs-params">moduleId</span> =&gt;</span> !modules[moduleId].isInitialized)
  .map(<span class="hljs-function"><span class="hljs-params">moduleId</span> =&gt;</span> modules[moduleId].verboseName);

<span class="hljs-comment">// make sure that the modules you expect to be waiting are actually waiting</span>
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">'loaded:'</span>,
  loadedModuleNames.length,
  <span class="hljs-string">'waiting:'</span>,
  waitingModuleNames.length
);

<span class="hljs-comment">// grab this text blob, and put it in a file named packager/moduleNames.js</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`module.exports = <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(loadedModuleNames.sort())}</span>;`</span>);
</code></pre>
<p>当你运行你的应用程序时，你可以查看 console 控制台，有多少模块已经加载，有多少模块在等待。你可能想查看 moduleNames，看看是否有任何意外。注意在首次 import 时调用的内联引用。你可能需要检查和重构，以确保只有你想要的模块在启动时加载。请注意，您可以根据需要修改 Systrace 对象，以帮助调试有问题的引用。</p>
<pre><code class="hljs"><span class="hljs-built_in">require</span>.Systrace.beginEvent = <span class="hljs-function"><span class="hljs-params">(message)</span> =&gt;</span> {
  <span class="hljs-keyword">if</span>(message.includes(problematicModule)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error();
  }
}
</code></pre>
<p>虽然每个 App 各有不同，但只加载第一个页面所需的模块是有普适意义的。当你满意时，把 loadedModuleNames 的输出放到 packager/moduleNames.js 文件中。</p>
<h3><a class="anchor" aria-hidden="true" id="转化模块路径"></a><a href="#转化模块路径" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>转化模块路径</h3>
<p>得到了需要预加载的模块名还不够，我们还需要模块的绝对路径，所以接下来将会搞定它。添加 <code>packager/generatemodulepaths.js</code> 文件：</p>
<pre><code class="hljs"><span class="hljs-comment">// @flow</span>
<span class="hljs-comment">/* eslint-disable no-console */</span>
<span class="hljs-keyword">const</span> execSync = <span class="hljs-built_in">require</span>(<span class="hljs-string">'child_process'</span>).execSync;
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> moduleNames = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./moduleNames'</span>);

<span class="hljs-keyword">const</span> pjson = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../package.json'</span>);
<span class="hljs-keyword">const</span> localPrefix = <span class="hljs-string">`<span class="hljs-subst">${pjson.name}</span>/`</span>;

<span class="hljs-keyword">const</span> modulePaths = moduleNames.map(<span class="hljs-function"><span class="hljs-params">moduleName</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (moduleName.startsWith(localPrefix)) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`./<span class="hljs-subst">${moduleName.substring(localPrefix.length)}</span>`</span>;
  }
  <span class="hljs-keyword">if</span> (moduleName.endsWith(<span class="hljs-string">'.js'</span>)) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`./node_modules/<span class="hljs-subst">${moduleName}</span>`</span>;
  }
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> result = execSync(
      <span class="hljs-string">`grep "@providesModule <span class="hljs-subst">${moduleName}</span>" $(find . -name <span class="hljs-subst">${moduleName}</span>\\\\.js) -l`</span>
    )
      .toString()
      .trim()
      .split(<span class="hljs-string">'\n'</span>)[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span> result;
    }
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
});

<span class="hljs-keyword">const</span> paths = modulePaths
  .filter(<span class="hljs-function"><span class="hljs-params">path</span> =&gt;</span> path != <span class="hljs-literal">null</span>)
  .map(<span class="hljs-function"><span class="hljs-params">path</span> =&gt;</span> <span class="hljs-string">`'<span class="hljs-subst">${path}</span>'`</span>)
  .join(<span class="hljs-string">',\n'</span>);

<span class="hljs-keyword">const</span> fileData = <span class="hljs-string">`module.exports = [<span class="hljs-subst">${paths}</span>];`</span>;

fs.writeFile(<span class="hljs-string">'./packager/modulePaths.js'</span>, fileData, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-built_in">console</span>.log(err);
  }

  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Done'</span>);
});
</code></pre>
<p>你可以通过<code>node packager/modulePaths.js</code>来运行这段脚本。</p>
<p>此脚本尝试从模块名称映射到模块路径，但它不是万无一失的。例如，它忽略了平台特定的文件（_ ios.js 和_ .android.js）。然而根据最初的测试，它处理了 95％的情况。当它运行一段时间后，它应该完成并输出一个名为<code>packager/modulePaths.js</code>的文件。它应该包含相对于你的项目根目录的模块文件路径。您可以将 modulePaths.js 提交到您的代码仓库，以便它可以被传递。</p>
<h3><a class="anchor" aria-hidden="true" id="更新配置文件"></a><a href="#更新配置文件" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>更新配置文件</h3>
<p>Returning to packager/config.js we should update it to use our newly generated modulePaths.js file.</p>
<pre><code class="hljs">const modulePaths = require(<span class="hljs-string">'./modulePaths'</span>);
const resolve = require(<span class="hljs-string">'path'</span>).resolve;
const fs = require(<span class="hljs-string">'fs'</span>);

const<span class="hljs-built_in"> config </span>= {
  getTransformOptions: () =&gt; {
    const moduleMap = {};
    modulePaths.<span class="hljs-keyword">forEach</span>(path =&gt; {
      <span class="hljs-keyword">if</span> (fs.existsSync(path)) {
        moduleMap[resolve(path)] = <span class="hljs-literal">true</span>;
      }
    });
    return {
      preloadedModules: moduleMap,
      transform: { inlineRequires: { blacklist: moduleMap } },
    };
  },
};

module.exports =<span class="hljs-built_in"> config;
</span></code></pre>
<p>配置文件中的 preloadedModules 条目指示哪些模块应被标记为由 unbundler 预加载。当 bundle 被加载时，这些模块立即被加载，甚至在任何 requires 执行之前。blacklist 表明这些模块不应该被要求内联引用，因为它们是预加载的，所以使用内联没有性能优势。实际上每次解析内联引用 JavaScript 都会花费额外的时间。</p>
<h3><a class="anchor" aria-hidden="true" id="测试和衡量改进"></a><a href="#测试和衡量改进" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>测试和衡量改进</h3>
<p>您现在应该准备好使用分拆和内联引用来构建您的应用了。保存启动前后的时间，来测试下有多少改进吧！</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/0.51/javascript-environment"><span class="arrow-prev">← </span><span class="function-name-prevnext">JavaScript环境</span></a><a class="docs-next button" href="/docs/0.51/upgrading"><span>更新</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#关于帧你所需要知道的">关于“帧”你所需要知道的</a><ul class="toc-headings"><li><a href="#javascript-帧率">JavaScript 帧率</a></li><li><a href="#主线程-也即-ui-线程-帧率">主线程 (也即 UI 线程) 帧率</a></li></ul></li><li><a href="#性能问题的常见原因">性能问题的常见原因</a><ul class="toc-headings"><li><a href="#consolelog-语句">console.log 语句</a></li><li><a href="#开发模式-devtrue">开发模式 (dev=true)</a></li><li><a href="#缓慢的导航器navigator切换">缓慢的导航器(Navigator)切换</a></li><li><a href="#listview-初始化渲染太慢以及列表过长时滚动性能太差">ListView 初始化渲染太慢以及列表过长时滚动性能太差</a></li><li><a href="#我的组件渲染太慢，我不需要立即显示全部">我的组件渲染太慢，我不需要立即显示全部</a></li><li><a href="#在重绘一个几乎没有什么变化的页面时，js-帧率严重降低">在重绘一个几乎没有什么变化的页面时，JS 帧率严重降低</a></li><li><a href="#由于在-javascript-线程中同时做很多事情，导致-js-线程掉帧">由于在 JavaScript 线程中同时做很多事情，导致 JS 线程掉帧</a></li><li><a href="#在屏幕上移动视图（滚动，切换，旋转）时，ui-线程掉帧">在屏幕上移动视图（滚动，切换，旋转）时，UI 线程掉帧</a></li><li><a href="#使用动画改变图片的尺寸时，ui-线程掉帧">使用动画改变图片的尺寸时，UI 线程掉帧</a></li><li><a href="#touchable-系列组件不能很好的响应">Touchable 系列组件不能很好的响应</a></li></ul></li><li><a href="#分析">分析</a></li><li><a href="#拆包和内联引用">拆包和内联引用</a><ul class="toc-headings"><li><a href="#loading-javascript">Loading JavaScript</a></li><li><a href="#内联引用">内联引用</a></li><li><a href="#启用拆包unbundling">启用拆包(Unbundling)</a></li><li><a href="#配置预加载及内联引用">配置预加载及内联引用</a></li><li><a href="#添加-packager-配置文件">添加 packager 配置文件</a></li><li><a href="#调试预加载的模块">调试预加载的模块</a></li><li><a href="#转化模块路径">转化模块路径</a></li><li><a href="#更新配置文件">更新配置文件</a></li><li><a href="#测试和衡量改进">测试和衡量改进</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="copyright"><p style="color:inherit">React Native中文网 © 2020</p></section></footer></div></body></html>